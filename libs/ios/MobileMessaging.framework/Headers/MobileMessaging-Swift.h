#if 0
#elif defined(__arm64__) && __arm64__
// Generated by Apple Swift version 5.9.2 (swiftlang-5.9.2.2.56 clang-1500.1.0.2.5)
#ifndef MOBILEMESSAGING_SWIFT_H
#define MOBILEMESSAGING_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#if defined(__OBJC__)
#include <Foundation/Foundation.h>
#endif
#if defined(__cplusplus)
#include <cstdint>
#include <cstddef>
#include <cstdbool>
#include <cstring>
#include <stdlib.h>
#include <new>
#include <type_traits>
#else
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <string.h>
#endif
#if defined(__cplusplus)
#if defined(__arm64e__) && __has_include(<ptrauth.h>)
# include <ptrauth.h>
#else
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wreserved-macro-identifier"
# ifndef __ptrauth_swift_value_witness_function_pointer
#  define __ptrauth_swift_value_witness_function_pointer(x)
# endif
# ifndef __ptrauth_swift_class_method_pointer
#  define __ptrauth_swift_class_method_pointer(x)
# endif
#pragma clang diagnostic pop
#endif
#endif

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...) 
# endif
#endif
#if !defined(SWIFT_RUNTIME_NAME)
# if __has_attribute(objc_runtime_name)
#  define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
# else
#  define SWIFT_RUNTIME_NAME(X) 
# endif
#endif
#if !defined(SWIFT_COMPILE_NAME)
# if __has_attribute(swift_name)
#  define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
# else
#  define SWIFT_COMPILE_NAME(X) 
# endif
#endif
#if !defined(SWIFT_METHOD_FAMILY)
# if __has_attribute(objc_method_family)
#  define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
# else
#  define SWIFT_METHOD_FAMILY(X) 
# endif
#endif
#if !defined(SWIFT_NOESCAPE)
# if __has_attribute(noescape)
#  define SWIFT_NOESCAPE __attribute__((noescape))
# else
#  define SWIFT_NOESCAPE 
# endif
#endif
#if !defined(SWIFT_RELEASES_ARGUMENT)
# if __has_attribute(ns_consumed)
#  define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
# else
#  define SWIFT_RELEASES_ARGUMENT 
# endif
#endif
#if !defined(SWIFT_WARN_UNUSED_RESULT)
# if __has_attribute(warn_unused_result)
#  define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
# else
#  define SWIFT_WARN_UNUSED_RESULT 
# endif
#endif
#if !defined(SWIFT_NORETURN)
# if __has_attribute(noreturn)
#  define SWIFT_NORETURN __attribute__((noreturn))
# else
#  define SWIFT_NORETURN 
# endif
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA 
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA 
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA 
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif
#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif
#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER 
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility) 
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED_OBJC)
# if __has_feature(attribute_diagnose_if_objc)
#  define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
# else
#  define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
# endif
#endif
#if defined(__OBJC__)
#if !defined(IBSegueAction)
# define IBSegueAction 
#endif
#endif
#if !defined(SWIFT_EXTERN)
# if defined(__cplusplus)
#  define SWIFT_EXTERN extern "C"
# else
#  define SWIFT_EXTERN extern
# endif
#endif
#if !defined(SWIFT_CALL)
# define SWIFT_CALL __attribute__((swiftcall))
#endif
#if !defined(SWIFT_INDIRECT_RESULT)
# define SWIFT_INDIRECT_RESULT __attribute__((swift_indirect_result))
#endif
#if !defined(SWIFT_CONTEXT)
# define SWIFT_CONTEXT __attribute__((swift_context))
#endif
#if !defined(SWIFT_ERROR_RESULT)
# define SWIFT_ERROR_RESULT __attribute__((swift_error_result))
#endif
#if defined(__cplusplus)
# define SWIFT_NOEXCEPT noexcept
#else
# define SWIFT_NOEXCEPT 
#endif
#if !defined(SWIFT_C_INLINE_THUNK)
# if __has_attribute(always_inline)
# if __has_attribute(nodebug)
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline)) __attribute__((nodebug))
# else
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline))
# endif
# else
#  define SWIFT_C_INLINE_THUNK inline
# endif
#endif
#if defined(_WIN32)
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL __declspec(dllimport)
#endif
#else
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL 
#endif
#endif
#if defined(__OBJC__)
#if __has_feature(objc_modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import CoreData;
@import CoreFoundation;
@import CoreLocation;
@import Dispatch;
@import Foundation;
@import ObjectiveC;
@import UIKit;
@import WebKit;
#endif

#endif
#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="MobileMessaging",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

#if defined(__OBJC__)
@class UIImage;
@class CALayer;
@class NSCoder;

/// <code>AnimatedImageView</code> is a subclass of <code>UIImageView</code> for displaying animated image.
SWIFT_CLASS("_TtC15MobileMessaging17AnimatedImageView")
@interface AnimatedImageView : UIImageView
@property (nonatomic, strong) UIImage * _Nullable image;
@property (nonatomic, readonly, getter=isAnimating) BOOL animating;
/// Starts the animation.
- (void)startAnimating;
/// Stops the animation.
- (void)stopAnimating;
- (void)displayLayer:(CALayer * _Nonnull)layer;
- (void)didMoveToWindow;
- (void)didMoveToSuperview;
- (nonnull instancetype)initWithImage:(UIImage * _Nullable)image OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithImage:(UIImage * _Nullable)image highlightedImage:(UIImage * _Nullable)highlightedImage OBJC_DESIGNATED_INITIALIZER SWIFT_AVAILABILITY(ios,introduced=3.0);
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@end


@class NSString;

/// The subclass of <code>NSOperation</code> from which all other operations should be derived.
/// This class adds both Conditions and Observers, which allow the operation to define
/// extended readiness requirements, as well as notify many interested parties
/// about interesting operation state changes
SWIFT_CLASS("_TtC15MobileMessaging9Operation")
@interface Operation : NSOperation
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (void)observeValueForKeyPath:(NSString * _Nullable)keyPath ofObject:(id _Nullable)object change:(NSDictionary<NSKeyValueChangeKey, id> * _Nullable)change context:(void * _Nullable)context;
@property (nonatomic, readonly, getter=isReady) BOOL ready;
@property (nonatomic, readonly, getter=isExecuting) BOOL executing;
@property (nonatomic, readonly, getter=isFinished) BOOL finished;
@property (nonatomic, readonly, getter=isCancelled) BOOL cancelled;
- (void)addDependency:(NSOperation * _Nonnull)operation;
- (void)main;
- (void)cancel;
@end


/// A sublcass of <code>Operation</code> to execute a closure.
SWIFT_CLASS("_TtC15MobileMessaging14BlockOperation")
@interface BlockOperation : Operation
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end





@class NSEntityDescription;
@class NSManagedObjectContext;

SWIFT_CLASS_NAMED("GeoEventReportObject")
@interface GeoEventReportObject : NSManagedObject
- (nonnull instancetype)initWithEntity:(NSEntityDescription * _Nonnull)entity insertIntoManagedObjectContext:(NSManagedObjectContext * _Nullable)context OBJC_DESIGNATED_INITIALIZER;
@end

@class NSDate;

@interface GeoEventReportObject (SWIFT_EXTENSION(MobileMessaging))
@property (nonatomic, copy) NSString * _Nonnull geoAreaId;
@property (nonatomic, copy) NSDate * _Nonnull eventDate;
@property (nonatomic, copy) NSString * _Nonnull eventType;
@property (nonatomic, copy) NSString * _Nonnull campaignId;
@property (nonatomic, copy) NSString * _Nonnull messageId;
@property (nonatomic, copy) NSString * _Nonnull sdkMessageId;
@property (nonatomic) BOOL messageShown;
@end


/// A subclass of <code>Operation</code> that executes zero or more operations as part of its
/// own execution. This class of operation is very useful for abstracting several
/// smaller operations into a larger operation. As an example, the <code>GetEarthquakesOperation</code>
/// is composed of both a <code>DownloadEarthquakesOperation</code> and a <code>ParseEarthquakesOperation</code>.
/// Additionally, <code>GroupOperation</code>s are useful if you establish a chain of dependencies,
/// but part of the chain may “loop”. For example, if you have an operation that
/// requires the user to be authenticated, you may consider putting the “login”
/// operation inside a group operation. That way, the “login” operation may produce
/// subsequent operations (still within the outer <code>GroupOperation</code>) that will all
/// be executed before the rest of the operations in the initial chain of operations.
SWIFT_CLASS("_TtC15MobileMessaging14GroupOperation")
@interface GroupOperation : Operation
- (void)cancel;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class OperationQueue;
@class NSError;

/// The delegate of an <code>OperationQueue</code> can respond to <code>Operation</code> lifecycle
/// events by implementing these methods.
/// In general, implementing <code>OperationQueueDelegate</code> is not necessary; you would
/// want to use an <code>OperationObserver</code> instead. However, there are a couple of
/// situations where using <code>OperationQueueDelegate</code> can lead to simpler code.
/// For example, <code>GroupOperation</code> is the delegate of its own internal
/// <code>OperationQueue</code> and uses it to manage dependencies.
SWIFT_PROTOCOL("_TtP15MobileMessaging22OperationQueueDelegate_")
@protocol OperationQueueDelegate <NSObject>
@optional
- (void)operationQueue:(OperationQueue * _Nonnull)operationQueue willAddOperation:(NSOperation * _Nonnull)operation;
- (void)operationQueue:(OperationQueue * _Nonnull)operationQueue operationDidFinish:(NSOperation * _Nonnull)operation withErrors:(NSArray<NSError *> * _Nonnull)errors;
@end


@interface GroupOperation (SWIFT_EXTENSION(MobileMessaging)) <OperationQueueDelegate>
- (void)operationQueue:(OperationQueue * _Nonnull)operationQueue willAddOperation:(NSOperation * _Nonnull)operation;
- (void)operationQueue:(OperationQueue * _Nonnull)operationQueue operationDidFinish:(NSOperation * _Nonnull)operation withErrors:(NSArray<NSError *> * _Nonnull)errors;
@end




SWIFT_CLASS("_TtC15MobileMessaging12InternalData")
@interface InternalData : NSObject <NSCopying, NSSecureCoding>
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
+ (void)setSupportsSecureCoding:(BOOL)value;
///
- (id _Nonnull)copyWithZone:(struct _NSZone * _Nullable)zone SWIFT_WARN_UNUSED_RESULT;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_PROTOCOL("_TtP15MobileMessaging27MMActivityIndicatorProtocol_")
@protocol MMActivityIndicatorProtocol
- (void)startAnimating;
- (void)stopAnimating;
@end

@class UIColor;
@class UIFont;

SWIFT_CLASS("_TtC15MobileMessaging22MMAdvancedChatSettings")
@interface MMAdvancedChatSettings : NSObject
@property (nonatomic) CGFloat textContainerTopMargin;
@property (nonatomic) CGFloat textContainerBottomMargin;
@property (nonatomic) CGFloat textContainerLeftPadding;
@property (nonatomic) CGFloat textContainerRightPadding;
@property (nonatomic) CGFloat textContainerTopPadding;
@property (nonatomic) CGFloat textContainerCornerRadius;
@property (nonatomic) CGFloat textViewTopMargin;
@property (nonatomic) CGFloat placeholderHeight;
@property (nonatomic) CGFloat placeholderSideMargin;
@property (nonatomic) CGFloat placeholderTopMargin;
@property (nonatomic) CGFloat buttonHeight;
@property (nonatomic) CGFloat buttonTouchableOverlap;
@property (nonatomic) CGFloat buttonRightMargin;
@property (nonatomic) CGFloat buttonBottomMargin;
@property (nonatomic) CGFloat utilityButtonWidth;
@property (nonatomic) CGFloat utilityButtonHeight;
@property (nonatomic) CGFloat utilityButtonBottomMargin;
@property (nonatomic) CGFloat initialHeight;
@property (nonatomic, strong) UIColor * _Nonnull mainTextColor;
@property (nonatomic, strong) UIColor * _Nonnull mainPlaceholderTextColor;
@property (nonatomic, strong) UIColor * _Nonnull textInputBackgroundColor;
@property (nonatomic, strong) UIColor * _Nonnull typingIndicatorColor;
@property (nonatomic, strong) UIColor * _Nonnull inputContainerBackgroundColor;
@property (nonatomic, strong) UIImage * _Nullable sendButtonIcon;
@property (nonatomic, strong) UIImage * _Nullable attachmentButtonIcon;
@property (nonatomic) BOOL isLineSeparatorHidden;
@property (nonatomic, strong) UIFont * _Nullable mainFont;
@property (nonatomic, strong) UIFont * _Nullable charCountFont;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_PROTOCOL("_TtP15MobileMessaging15MMAttributeType_")
@protocol MMAttributeType
@end


SWIFT_CLASS("_TtC15MobileMessaging11MMBaseEvent")
@interface MMBaseEvent : NSObject
/// Event ID that is generated on the Portal for your custom Event Definition.
@property (nonatomic, readonly, copy) NSString * _Nonnull definitionId;
- (nonnull instancetype)initWithDefinitionId:(NSString * _Nonnull)definitionId OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

enum MMMessageDirection : int16_t;
enum MMMessageDeliveryMethod : int16_t;

SWIFT_CLASS("_TtC15MobileMessaging13MMBaseMessage")
@interface MMBaseMessage : NSObject
/// Custom data
@property (nonatomic, copy) NSDictionary<NSString *, id> * _Nullable customPayload;
/// Indicates whether the message is incoming (MT) or outgoing (MO)
@property (nonatomic) enum MMMessageDirection direction;
/// Message id
@property (nonatomic, copy) NSString * _Nonnull messageId;
/// Original message payload
@property (nonatomic, copy) NSDictionary<NSString *, id> * _Nonnull originalPayload;
/// Defines the origin of a message.
/// Message may be either pushed by APNS, generated locally or pulled from the server.
@property (nonatomic) enum MMMessageDeliveryMethod deliveryMethod;
/// Text of the message
@property (nonatomic, copy) NSString * _Nullable text;
/// Indicates whether the message is chat message
@property (nonatomic, readonly) BOOL isChatMessage;
- (nonnull instancetype)initWithMessageId:(NSString * _Nonnull)messageId direction:(enum MMMessageDirection)direction originalPayload:(NSDictionary<NSString *, id> * _Nonnull)originalPayload deliveryMethod:(enum MMMessageDeliveryMethod)deliveryMethod OBJC_DESIGNATED_INITIALIZER;
- (BOOL)isEqualWithObject:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

typedef SWIFT_ENUM(int16_t, MMCampaignState, closed) {
  MMCampaignStateActive = 0,
  MMCampaignStateSuspended = 1,
  MMCampaignStateFinished = 2,
};

typedef SWIFT_ENUM(NSInteger, MMChatMultiThreadStrategy, closed) {
  MMChatMultiThreadStrategyACTIVE = 0,
  MMChatMultiThreadStrategyALL = 1,
};

@class UIViewController;
@class NSBundle;

/// Chat view implementation, extends UINavigationController with a ChatViewController put as a root view controller.
SWIFT_CLASS("_TtC15MobileMessaging18MMChatNavigationVC")
@interface MMChatNavigationVC : UINavigationController
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithRootViewController:(UIViewController * _Nonnull)rootViewController SWIFT_UNAVAILABLE;
- (nonnull instancetype)initWithNibName:(NSString * _Nullable)nibNameOrNil bundle:(NSBundle * _Nullable)nibBundleOrNil SWIFT_UNAVAILABLE;
- (void)viewWillAppear:(BOOL)animated;
- (nonnull instancetype)initWithNavigationBarClass:(Class _Nullable)navigationBarClass toolbarClass:(Class _Nullable)toolbarClass SWIFT_UNAVAILABLE;
@end

@class UIBarButtonItem;

SWIFT_CLASS("_TtC15MobileMessaging14MMChatSettings")
@interface MMChatSettings : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) MMChatSettings * _Nonnull settings;)
+ (MMChatSettings * _Nonnull)settings SWIFT_WARN_UNUSED_RESULT;
+ (void)setSettings:(MMChatSettings * _Nonnull)value;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) MMChatSettings * _Nullable darkSettings SWIFT_DEPRECATED_MSG("The variable `widgetTheme` and `settings` should now be used instead for altering the chat colours. This variable will be removed in a future release");)
+ (MMChatSettings * _Nullable)darkSettings SWIFT_WARN_UNUSED_RESULT;
+ (void)setDarkSettings:(MMChatSettings * _Nullable)value;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) MMChatSettings * _Nonnull sharedInstance;)
+ (MMChatSettings * _Nonnull)sharedInstance SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, copy) NSString * _Nullable title;
@property (nonatomic, strong) UIColor * _Nullable sendButtonTintColor;
@property (nonatomic, strong) UIColor * _Nullable navBarItemsTintColor;
@property (nonatomic, strong) UIColor * _Nullable navBarColor;
@property (nonatomic, strong) UIColor * _Nullable navBarTitleColor;
@property (nonatomic, strong) UIColor * _Nullable attachmentPreviewBarsColor;
@property (nonatomic, strong) UIColor * _Nullable attachmentPreviewItemsColor;
@property (nonatomic, strong) UIColor * _Nullable backgroundColor;
@property (nonatomic, strong) UIColor * _Nullable errorLabelTextColor;
@property (nonatomic, strong) UIColor * _Nullable errorLabelBackgroundColor;
@property (nonatomic) BOOL shouldSetNavBarAppearance;
@property (nonatomic) BOOL shouldHandleKeyboardAppearance;
@property (nonatomic) BOOL shouldUseExternalChatInput;
@property (nonatomic, copy) NSString * _Nullable widgetTheme;
@property (nonatomic, strong) MMAdvancedChatSettings * _Nonnull advancedSettings;
@property (nonatomic, strong) UIBarButtonItem * _Nullable multithreadBackButton;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


@interface MMChatSettings (SWIFT_EXTENSION(MobileMessaging))
- (void)configureWithRawConfig:(NSDictionary<NSString *, id> * _Nonnull)rawConfig;
@end


SWIFT_CLASS("_TtC15MobileMessaging32MMModalDismissableViewController")
@interface MMModalDismissableViewController : UIViewController
- (void)viewWillAppear:(BOOL)animated;
- (nonnull instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithNibName:(NSString * _Nullable)nibNameOrNil bundle:(NSBundle * _Nullable)nibBundleOrNil SWIFT_UNAVAILABLE;
- (void)viewDidLoad;
@end


SWIFT_CLASS("_TtC15MobileMessaging29MMKeyboardAwareViewController")
@interface MMKeyboardAwareViewController : MMModalDismissableViewController
- (void)viewDidLoad;
- (nonnull instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC15MobileMessaging35MMKeyboardAwareScrollViewController")
@interface MMKeyboardAwareScrollViewController : MMKeyboardAwareViewController
- (void)viewWillLayoutSubviews;
- (nonnull instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
@end

@class UIGestureRecognizer;
@class UIScrollView;

SWIFT_CLASS("_TtC15MobileMessaging32MMMessageComposingViewController")
@interface MMMessageComposingViewController : MMKeyboardAwareScrollViewController <UIGestureRecognizerDelegate, UINavigationControllerDelegate, UIScrollViewDelegate>
- (void)viewDidLoad;
- (void)viewWillDisappear:(BOOL)animated;
- (void)viewDidLayoutSubviews;
- (BOOL)gestureRecognizer:(UIGestureRecognizer * _Nonnull)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer * _Nonnull)otherGestureRecognizer SWIFT_WARN_UNUSED_RESULT;
- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer * _Nonnull)gestureRecognizer SWIFT_WARN_UNUSED_RESULT;
- (void)scrollViewWillBeginDragging:(UIScrollView * _Nonnull)scrollView;
- (void)scrollViewDidEndDragging:(UIScrollView * _Nonnull)scrollView willDecelerate:(BOOL)decelerate;
- (void)scrollViewDidEndDecelerating:(UIScrollView * _Nonnull)scrollView;
- (nonnull instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
@end

@class WKWebView;
@class WKNavigation;

/// Key component to use for displaying In-app chat view.
/// We support two ways to quickly embed it into your own application:
/// <ul>
///   <li>
///     via Interface Builder: set it as <code>Custom class</code> for your view controller object.
///   </li>
///   <li>
///     programmatically: use one of the <code>make</code> methods provided.
///   </li>
/// </ul>
SWIFT_CLASS("_TtC15MobileMessaging20MMChatViewController")
@interface MMChatViewController : MMMessageComposingViewController
- (void)loadView;
- (void)viewDidLoad;
- (void)viewWillDisappear:(BOOL)animated;
- (void)viewDidAppear:(BOOL)animated;
- (void)viewDidDisappear:(BOOL)animated;
- (void)webView:(WKWebView * _Nonnull)webView didFinishNavigation:(WKNavigation * _Null_unspecified)navigation;
- (void)webView:(WKWebView * _Nonnull)webView didStartProvisionalNavigation:(WKNavigation * _Null_unspecified)navigation;
/// Method for sending metadata to conversations backend. It can be called any time, many times, but once the chat has started and is presented.
/// The format of the metadata must be that of Javascript objects and values (for guidance, it must be a string accepted by JSON.stringify()
/// The multiThreadStrategy is entirely optional and we recommented to leave as default ACTIVE.
- (void)sendContextualData:(NSString * _Nonnull)metadata multiThreadStrategy:(enum MMChatMultiThreadStrategy)multiThreadStrategy completion:(void (^ _Nonnull)(NSError * _Nullable))completion;
- (nonnull instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
@end

@class WKNavigationAction;

@interface MMChatViewController (SWIFT_EXTENSION(MobileMessaging)) <WKNavigationDelegate>
- (void)webView:(WKWebView * _Nonnull)webView decidePolicyForNavigationAction:(WKNavigationAction * _Nonnull)navigationAction decisionHandler:(void (^ _Nonnull)(WKNavigationActionPolicy))decisionHandler;
@end

@class UITraitCollection;

@interface MMChatViewController (SWIFT_EXTENSION(MobileMessaging))
- (void)traitCollectionDidChange:(UITraitCollection * _Nullable)previousTraitCollection;
@end


typedef SWIFT_ENUM(NSInteger, MMChatWebViewState, closed) {
  MMChatWebViewStateLoading = 0,
  MMChatWebViewStateThreadList = 1,
  MMChatWebViewStateLoadingThread = 2,
  MMChatWebViewStateThread = 3,
  MMChatWebViewStateSingleThreadMode = 4,
  MMChatWebViewStateClosedThread = 5,
  MMChatWebViewStateUnknown = 6,
};


/// CustomEvent class represents Custom event. Events allow you to track arbitrary user actions and collect arbitrary contextual information represented by event key-value properties.
SWIFT_CLASS("_TtC15MobileMessaging13MMCustomEvent")
@interface MMCustomEvent : MMBaseEvent
/// Arbitrary contextual data of the custom event.
@property (nonatomic, readonly, copy) NSDictionary<NSString *, id <MMAttributeType>> * _Nullable properties;
/// Initializes a custom event.
/// \param definitionId Event ID that is generated on the Portal for your custom Event Definition.
///
/// \param properties Arbitrary contextual data of the custom event.
///
- (nonnull instancetype)initWithDefinitionId:(NSString * _Nonnull)definitionId properties:(NSDictionary<NSString *, id <MMAttributeType>> * _Nullable)properties OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithDictRepresentation:(NSDictionary<NSString *, id> * _Nonnull)dict;
- (nonnull instancetype)initWithDefinitionId:(NSString * _Nonnull)definitionId SWIFT_UNAVAILABLE;
@end


SWIFT_CLASS("_TtC15MobileMessaging10MMDateTime")
@interface MMDateTime : NSObject <NSSecureCoding>
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
+ (void)setSupportsSecureCoding:(BOOL)value;
@property (nonatomic, readonly, strong) NSDate * _Nonnull date;
- (nonnull instancetype)initWithDate:(NSDate * _Nonnull)date OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


@interface MMDateTime (SWIFT_EXTENSION(MobileMessaging)) <MMAttributeType>
@end

typedef SWIFT_ENUM(int8_t, MMDay, closed) {
  MMDayMo = 1,
  MMDayTu = 2,
  MMDayWe = 3,
  MMDayTh = 4,
  MMDayFr = 5,
  MMDaySa = 6,
  MMDaySu = 7,
};

@class MMLogOutput;
enum MMLogLevel : NSUInteger;

SWIFT_PROTOCOL("_TtP15MobileMessaging9MMLogging_")
@protocol MMLogging
@property (nonatomic, strong) MMLogOutput * _Nonnull logOutput;
@property (nonatomic) enum MMLogLevel logLevel;
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nullable logFilePaths;
- (void)sendLogsFromViewController:(UIViewController * _Nonnull)vc;
- (void)logDebugWithMessage:(NSString * _Nonnull)message;
- (void)logInfoWithMessage:(NSString * _Nonnull)message;
- (void)logErrorWithMessage:(NSString * _Nonnull)message;
- (void)logWarnWithMessage:(NSString * _Nonnull)message;
- (void)logVerboseWithMessage:(NSString * _Nonnull)message;
@end


SWIFT_CLASS("_TtC15MobileMessaging15MMDefaultLogger")
@interface MMDefaultLogger : NSObject <MMLogging>
@property (nonatomic, strong) MMLogOutput * _Nonnull logOutput;
@property (nonatomic) enum MMLogLevel logLevel;
@property (nonatomic, copy) NSArray<NSString *> * _Nullable logFilePaths;
- (void)sendLogsFromViewController:(UIViewController * _Nonnull)vc;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (void)logDebugWithMessage:(NSString * _Nonnull)message;
- (void)logInfoWithMessage:(NSString * _Nonnull)message;
- (void)logErrorWithMessage:(NSString * _Nonnull)message;
- (void)logWarnWithMessage:(NSString * _Nonnull)message;
- (void)logVerboseWithMessage:(NSString * _Nonnull)message;
@end

@class MMQuery;

SWIFT_PROTOCOL("_TtP15MobileMessaging24MMMessageStorageRemovers_")
@protocol MMMessageStorageRemovers
- (void)removeAllMessagesWithCompletion:(void (^ _Nonnull)(NSArray<NSString *> * _Nonnull))completion;
- (void)removeWithIds:(NSArray<NSString *> * _Nonnull)messageIds completion:(void (^ _Nonnull)(NSArray<NSString *> * _Nonnull))completion;
- (void)removeWithQuery:(MMQuery * _Nonnull)query completion:(void (^ _Nonnull)(NSArray<NSString *> * _Nonnull))completion;
@end


SWIFT_PROTOCOL("_TtP15MobileMessaging23MMMessageStorageFinders_")
@protocol MMMessageStorageFinders
@property (nonatomic, copy) void (^ _Nullable messagesCountersUpdateHandler)(NSInteger, NSInteger);
- (void)countAllMessagesWithCompletion:(void (^ _Nonnull)(NSInteger))completion;
- (void)findAllMessagesWithCompletion:(void (^ _Nonnull)(NSArray<MMBaseMessage *> * _Nullable))completion;
- (void)findAllMessageIdsWithCompletion:(void (^ _Nonnull)(NSArray<NSString *> * _Nonnull))completion;
- (void)findNonSeenMessageIdsWithCompletion:(void (^ _Nonnull)(NSArray<NSString *> * _Nonnull))completion;
- (void)findMessagesWithIds:(NSArray<NSString *> * _Nonnull)messageIds completion:(void (^ _Nonnull)(NSArray<MMBaseMessage *> * _Nullable))completion;
- (void)findMessagesWithQuery:(MMQuery * _Nonnull)query completion:(void (^ _Nonnull)(NSArray<MMBaseMessage *> * _Nullable))completion;
@end

enum MMSeenStatus : int16_t;
enum MM_MOMessageSentStatus : int16_t;

/// The protocol describes implementation of the Message Storage. The Message Storage persists all the messages (both mobile originated and mobile terminated).
SWIFT_PROTOCOL("_TtP15MobileMessaging16MMMessageStorage_")
@protocol MMMessageStorage
/// The queue in which all the hooks(inserts, updates) are dispatched.
/// The queue must be provided by the particular implementation of this protocol in order to provide thread safety and performance aspects.
@property (nonatomic, readonly, strong) dispatch_queue_t _Nonnull queue;
/// This method is called by the Mobile Messaging SDK during the initialization process. You implement your custom preparation routine here if needed.
- (void)start;
/// This method is called by the Mobile Messaging SDK while stopping the currently running session (see also <code>MobileMessaging.stop()</code> method). You implement your custom deinitialization routine here if needed.
- (void)stop;
/// This method is called whenever a new mobile originated message is about to be sent to the server.
- (void)insertWithOutgoing:(NSArray<MMBaseMessage *> * _Nonnull)messages completion:(void (^ _Nonnull)(void))completion;
/// This method is called whenever a new mobile terminated message (either push(remote) notifictaion or fetched message) is received by the Mobile Messaging SDK.
- (void)insertWithIncoming:(NSArray<MMBaseMessage *> * _Nonnull)messages completion:(void (^ _Nonnull)(void))completion;
/// This method is used by the Mobile Messaging SDK in order to detect duplicated messages persisted in the Message Storage. It is strongly recommended to implement this method in your custom Message Storage.
/// \param messageId unique identifier of a MT message. Consider this identifier as a primary key.
///
- (MMBaseMessage * _Nullable)findMessageWithId:(NSString * _Nonnull)messageId SWIFT_WARN_UNUSED_RESULT;
/// This method is called whenever the seen status is updated for a particular mobile terminated (MT) message.
/// \param status actual seen status for a message
///
/// \param messageId unique identifier of a MT message
///
- (void)updateWithMessageSeenStatus:(enum MMSeenStatus)status for:(NSString * _Nonnull)messageId completion:(void (^ _Nonnull)(void))completion;
/// This method is called whenever the delivery report is updated for a particular mobile terminated (MT) message.
/// \param isDelivered boolean flag which defines whether the delivery report for a message was successfully sent
///
/// \param messageId unique identifier of a MT message
///
- (void)updateWithDeliveryReportStatus:(BOOL)isDelivered for:(NSString * _Nonnull)messageId completion:(void (^ _Nonnull)(void))completion;
/// This method is called whenever the sending status is updated for a particular mobile originated (MO) message.
/// \param status actual sending status for a MO message
///
/// \param messageId unique identifier of a MO message
///
- (void)updateWithMessageSentStatus:(enum MM_MOMessageSentStatus)status for:(NSString * _Nonnull)messageId completion:(void (^ _Nonnull)(void))completion;
/// This method is used to fetch and return all stored chat messages ids.
/// \param completion a block to be executed after fetching is completed, all the fetched message ids must be passed as a block parameter
///
- (void)findAllMessageIdsWithCompletion:(void (^ _Nonnull)(NSArray<NSString *> * _Nonnull))completion;
@end


/// Default implementation of the Message Storage protocol. Uses Core Data persistent storage with SQLite database.
SWIFT_CLASS("_TtC15MobileMessaging23MMDefaultMessageStorage")
@interface MMDefaultMessageStorage : NSObject <MMMessageStorage, MMMessageStorageFinders, MMMessageStorageRemovers>
@property (nonatomic, copy) void (^ _Nullable messagesCountersUpdateHandler)(NSInteger, NSInteger);
- (void)countAllMessagesWithCompletion:(void (^ _Nonnull)(NSInteger))completion;
@property (nonatomic, readonly, strong) dispatch_queue_t _Nonnull queue;
- (void)start;
- (void)stop;
- (void)findAllMessageIdsWithCompletion:(void (^ _Nonnull)(NSArray<NSString *> * _Nonnull))completion;
- (void)findNonSeenMessageIdsWithCompletion:(void (^ _Nonnull)(NSArray<NSString *> * _Nonnull))completion;
- (void)insertWithOutgoing:(NSArray<MMBaseMessage *> * _Nonnull)messages completion:(void (^ _Nonnull)(void))completion;
- (void)insertWithIncoming:(NSArray<MMBaseMessage *> * _Nonnull)messages completion:(void (^ _Nonnull)(void))completion;
- (MMBaseMessage * _Nullable)findMessageWithId:(NSString * _Nonnull)messageId SWIFT_WARN_UNUSED_RESULT;
- (void)updateWithMessageSentStatus:(enum MM_MOMessageSentStatus)status for:(NSString * _Nonnull)messageId completion:(void (^ _Nonnull)(void))completion;
- (void)updateWithMessageSeenStatus:(enum MMSeenStatus)status for:(NSString * _Nonnull)messageId completion:(void (^ _Nonnull)(void))completion;
- (void)updateWithDeliveryReportStatus:(BOOL)isDelivered for:(NSString * _Nonnull)messageId completion:(void (^ _Nonnull)(void))completion;
- (void)findAllMessagesWithCompletion:(void (^ _Nonnull)(NSArray<MMBaseMessage *> * _Nullable))completion;
- (void)findMessagesWithIds:(NSArray<NSString *> * _Nonnull)messageIds completion:(void (^ _Nonnull)(NSArray<MMBaseMessage *> * _Nullable))completion;
- (void)findMessagesWithQuery:(MMQuery * _Nonnull)query completion:(void (^ _Nonnull)(NSArray<MMBaseMessage *> * _Nullable))completion;
- (void)removeAllMessagesWithCompletion:(void (^ _Nonnull)(NSArray<NSString *> * _Nonnull))completion;
- (void)removeWithIds:(NSArray<NSString *> * _Nonnull)messageIds completion:(void (^ _Nonnull)(NSArray<NSString *> * _Nonnull))completion;
- (void)removeWithQuery:(MMQuery * _Nonnull)query completion:(void (^ _Nonnull)(NSArray<NSString *> * _Nonnull))completion;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class MMDeliveryTimeInterval;

SWIFT_CLASS("_TtC15MobileMessaging14MMDeliveryTime")
@interface MMDeliveryTime : NSObject
@property (nonatomic, readonly, strong) MMDeliveryTimeInterval * _Nullable timeInterval;
- (nullable instancetype)initWithDictRepresentation:(NSDictionary<NSString *, id> * _Nonnull)dict;
@property (nonatomic, readonly, copy) NSDictionary<NSString *, id> * _Nonnull dictionaryRepresentation;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC15MobileMessaging22MMDeliveryTimeInterval")
@interface MMDeliveryTimeInterval : NSObject
- (nullable instancetype)initWithDictRepresentation:(NSDictionary<NSString *, id> * _Nonnull)dict;
@property (nonatomic, readonly, copy) NSDictionary<NSString *, id> * _Nonnull dictionaryRepresentation;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC15MobileMessaging7MMEmail")
@interface MMEmail : NSObject <NSSecureCoding>
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
+ (void)setSupportsSecureCoding:(BOOL)value;
@property (nonatomic, readonly, copy) NSString * _Nonnull address;
@property (nonatomic) BOOL preferred;
- (nullable instancetype)initWithDictRepresentation:(NSDictionary<NSString *, id> * _Nonnull)dict OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, readonly, copy) NSDictionary<NSString *, id> * _Nonnull dictionaryRepresentation;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)initWithAddress:(NSString * _Nonnull)address preferred:(BOOL)preferred OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

typedef SWIFT_ENUM(NSInteger, MMGenderNonnull, closed) {
  MMGenderNonnullFemale = 0,
  MMGenderNonnullMale = 1,
  MMGenderNonnullUndefined = 2,
};

@class MMRegion;

SWIFT_PROTOCOL("_TtP15MobileMessaging18MMGeoEventHandling_")
@protocol MMGeoEventHandling
/// This callback is triggered after the geo event occurs. Default behaviour is implemented by <code>MMDefaultGeoEventHandling</code> class.
- (void)didEnterWithRegion:(MMRegion * _Nonnull)region;
@end

@class MMNotificationAction;
@class NSURL;

SWIFT_CLASS("_TtC15MobileMessaging12MM_MTMessage")
@interface MM_MTMessage : MMBaseMessage
/// Contains info about the action was applied to the message
@property (nonatomic, strong) MMNotificationAction * _Nullable appliedAction;
/// Servers datetime
@property (nonatomic) NSTimeInterval sendDateTime;
/// Custom title for “Dismiss” button for in-app message alert
@property (nonatomic, copy) NSString * _Nullable inAppDismissTitle;
/// Custom title for “Open” button for in-app message alert
@property (nonatomic, copy) NSString * _Nullable inAppOpenTitle;
/// Messages seen status
@property (nonatomic) enum MMSeenStatus seenStatus;
/// Datetime that message was seen
@property (nonatomic, copy) NSDate * _Nullable seenDate;
/// Flag indicates whether the message was reported on delivery
@property (nonatomic) BOOL isDeliveryReportSent;
/// Datetime that message was reported on delivery
@property (nonatomic, copy) NSDate * _Nullable deliveryReportedDate;
/// Title of the message. If message title may be localized (“alert.title-loc-key” attribute is present and refers to an existing localized string), the localized string is returned, otherwise the value of “alert.title” attribute is returned if present.
@property (nonatomic, readonly, copy) NSString * _Nullable title;
/// Localization key of the message title.
@property (nonatomic, readonly, copy) NSString * _Nullable title_loc_key;
/// Localization args of the message title.
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nullable title_loc_args;
/// Localization key of the message text.
@property (nonatomic, readonly, copy) NSString * _Nullable loc_key;
/// Localization args of the message.
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nullable loc_args;
/// Sound of the message.
@property (nonatomic, readonly, copy) NSString * _Nullable sound;
/// Interactive category Id
@property (nonatomic, readonly, copy) NSString * _Nullable category;
/// Defines if a message is silent. Silent messages have neither text nor sound attributes.
@property (nonatomic, readonly) BOOL isSilent;
/// URL representing rich notification content
@property (nonatomic, readonly, copy) NSString * _Nullable contentUrl;
@property (nonatomic, readonly, copy) NSURL * _Nullable webViewUrl;
@property (nonatomic, readonly, copy) NSURL * _Nullable browserUrl;
@property (nonatomic, readonly, copy) NSURL * _Nullable deeplink;
@property (nonatomic, readonly) BOOL showInApp;
@property (nonatomic, readonly) BOOL isExpired;
@property (nonatomic, readonly, copy) NSString * _Nullable topic;
/// Indicates whether the message represents a geo campaign subscription
@property (nonatomic, readonly) BOOL isGeoSignalingMessage;
/// APNS payload (<code>aps</code> object) sent with the silent push notifications
@property (nonatomic, readonly, copy) NSDictionary<NSString *, id> * _Nullable silentData;
/// Internal data for internal use
@property (nonatomic, readonly, copy) NSDictionary<NSString *, id> * _Nullable internalData;
@property (nonatomic, copy) NSDictionary<NSString *, id> * _Nullable customPayload;
@property (nonatomic, copy) NSString * _Nullable text;
@property (nonatomic, readonly) BOOL isChatMessage;
/// Designated init
- (nullable instancetype)initWithPayload:(NSDictionary * _Nonnull)payload deliveryMethod:(enum MMMessageDeliveryMethod)deliveryMethod seenDate:(NSDate * _Nullable)seenDate deliveryReportDate:(NSDate * _Nullable)deliveryReportDate seenStatus:(enum MMSeenStatus)seenStatus isDeliveryReportSent:(BOOL)isDeliveryReportSent OBJC_DESIGNATED_INITIALIZER;
+ (MM_MTMessage * _Nullable)makeWithPayload:(NSDictionary * _Nonnull)payload SWIFT_WARN_UNUSED_RESULT;
+ (BOOL)isCorrectPayload:(NSDictionary * _Nonnull)payload SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSDictionary<NSString *, id> * _Nonnull dictionaryRepresentation;
- (nonnull instancetype)initWithMessageId:(NSString * _Nonnull)messageId direction:(enum MMMessageDirection)direction originalPayload:(NSDictionary<NSString *, id> * _Nonnull)originalPayload deliveryMethod:(enum MMMessageDeliveryMethod)deliveryMethod SWIFT_UNAVAILABLE;
@end


SWIFT_CLASS("_TtC15MobileMessaging12MMGeoMessage")
@interface MMGeoMessage : MM_MTMessage
@property (nonatomic, readonly, copy) NSString * _Nonnull campaignId;
@property (nonatomic, readonly, copy) NSSet<MMRegion *> * _Nonnull regions;
@property (nonatomic, readonly, copy) NSDate * _Nonnull startTime;
@property (nonatomic, readonly, copy) NSDate * _Nonnull expiryTime;
@property (nonatomic, readonly) BOOL isNotExpired;
@property (nonatomic) enum MMCampaignState campaignState;
- (nullable instancetype)initWithPayload:(NSDictionary * _Nonnull)payload deliveryMethod:(enum MMMessageDeliveryMethod)deliveryMethod seenDate:(NSDate * _Nullable)seenDate deliveryReportDate:(NSDate * _Nullable)deliveryReportDate seenStatus:(enum MMSeenStatus)seenStatus isDeliveryReportSent:(BOOL)isDeliveryReportSent OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, readonly) BOOL isNowAppropriateTimeForEntryNotification;
@property (nonatomic, readonly) BOOL isNowAppropriateTimeForExitNotification;
@end

/// Describes the capability status for Geofencing Service. Possible values:
/// <ul>
///   <li>
///     <code>notDetermined</code>: The capability has not been requested yet
///   </li>
///   <li>
///     <code>authorized</code>: The capability has been requested and approved
///   </li>
///   <li>
///     <code>denied</code>: The capability has been requested but was denied by the user
///   </li>
///   <li>
///     <code>notAvailable</code>: The capability is not available (perhaps due to restrictions, or lack of support)
///   </li>
/// </ul>
typedef SWIFT_ENUM(NSInteger, MMGeofencingCapabilityStatus, closed) {
  MMGeofencingCapabilityStatusNotDetermined = 0,
  MMGeofencingCapabilityStatusAuthorized = 1,
  MMGeofencingCapabilityStatusDenied = 2,
  MMGeofencingCapabilityStatusNotAvailable = 3,
};


SWIFT_CLASS("_TtC15MobileMessaging22MobileMessagingService")
@interface MobileMessagingService : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class MobileMessaging;
@class NSNotification;
@class CLLocation;
enum MMLocationServiceUsage : NSInteger;

SWIFT_CLASS("_TtC15MobileMessaging19MMGeofencingService")
@interface MMGeofencingService : MobileMessagingService
/// Starts the Geofencing Service
/// During the startup process, the service automatically asks user to grant the appropriate permissions
/// Once the user granted the permissions, the service succesfully lauches.
/// \param completion A block that will be triggered once the startup process is finished. Contains a Bool flag parameter, that indicates whether the startup succeded.
///
- (void)start:(void (^ _Nonnull)(BOOL))completion;
/// Stops the Geofencing Service
- (void)suspend;
- (void)stopService:(void (^ _Nonnull)(BOOL))completion;
- (void)depersonalizationStatusDidChange:(void (^ _Nonnull)(void))completion;
- (void)depersonalizeService:(MobileMessaging * _Nonnull)mmContext userInitiated:(BOOL)userInitiated completion:(void (^ _Nonnull)(void))completion;
- (void)mobileMessagingDidStart:(void (^ _Nonnull)(void))completion;
- (void)pushRegistrationStatusDidChange:(void (^ _Nonnull)(void))completion;
- (void)appDidFinishLaunching:(NSNotification * _Nonnull)notification completion:(void (^ _Nonnull)(void))completion;
- (void)appWillEnterForeground:(void (^ _Nonnull)(void))completion;
- (void)appDidEnterBackground:(void (^ _Nonnull)(void))completion;
- (void)appDidBecomeActive:(void (^ _Nonnull)(void))completion;
@property (nonatomic) BOOL isRunning;
@property (nonatomic, readonly, copy) NSDictionary<NSString *, NSObject *> * _Nullable systemData;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) BOOL isSystemDataGeofencingServiceEnabled;)
+ (BOOL)isSystemDataGeofencingServiceEnabled SWIFT_WARN_UNUSED_RESULT;
/// Returns current user location with accuracy <code>kCLLocationAccuracyHundredMeters</code>.
@property (nonatomic, readonly, strong) CLLocation * _Nullable currentUserLocation;
/// Returns all the regions available in the Geofencing Service storage.
@property (nonatomic, readonly, copy) NSArray<MMRegion *> * _Nonnull allRegions;
/// Returns current capability status for Geofencing Service. For more information see <code>MMGeofencingCapabilityStatus</code>.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly) enum MMGeofencingCapabilityStatus currentCapabilityStatus;)
+ (enum MMGeofencingCapabilityStatus)currentCapabilityStatus SWIFT_WARN_UNUSED_RESULT;
/// Requests permission to use location services whenever the app is running.
/// \param usage Defines the usage type for which permissions is requested.
///
/// \param completion A block that will be triggered once the authorization request is finished and the capability statys is defined. The current capability status is passed to the block as a parameter.
///
- (void)authorizeWithUsage:(enum MMLocationServiceUsage)usage completion:(void (^ _Nonnull)(enum MMGeofencingCapabilityStatus))completion;
/// Accepts a geo message, which contains regions that should be monitored.
/// \param message A message object to add to the monitoring. Object of <code>MMGeoMessage</code> class.
///
- (void)addWithMessage:(MMGeoMessage * _Nonnull)message completion:(void (^ _Nonnull)(void))completion;
/// Removes a message from the monitoring.
- (void)removeMessageWithId:(NSString * _Nonnull)messageId;
/// The geo event handling object defines the behaviour that is triggered during the geo event.
/// You can implement your own geo event handling either by subclassing <code>MMDefaultGeoEventHandling</code> or implementing the <code>MMGeoEventHandling</code> protocol.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) id <MMGeoEventHandling> _Nullable geoEventsHandler;)
+ (id <MMGeoEventHandling> _Nullable)geoEventsHandler SWIFT_WARN_UNUSED_RESULT;
+ (void)setGeoEventsHandler:(id <MMGeoEventHandling> _Nullable)value;
- (nonnull instancetype)initWithMmContext:(MobileMessaging * _Nonnull)mmContext uniqueIdentifier:(NSString * _Nonnull)uniqueIdentifier SWIFT_UNAVAILABLE;
@end


@class CLLocationManager;
@class CLRegion;

@interface MMGeofencingService (SWIFT_EXTENSION(MobileMessaging)) <CLLocationManagerDelegate>
- (void)locationManager:(CLLocationManager * _Nonnull)manager didChangeAuthorizationStatus:(CLAuthorizationStatus)status;
- (void)locationManager:(CLLocationManager * _Nonnull)manager didStartMonitoringForRegion:(CLRegion * _Nonnull)region;
- (void)locationManager:(CLLocationManager * _Nonnull)manager didEnterRegion:(CLRegion * _Nonnull)region;
- (void)locationManager:(CLLocationManager * _Nonnull)manager didFailWithError:(NSError * _Nonnull)error;
- (void)locationManager:(CLLocationManager * _Nonnull)manager didUpdateLocations:(NSArray<CLLocation *> * _Nonnull)locations;
@end


SWIFT_PROTOCOL("_TtP15MobileMessaging19MMInAppChatDelegate_")
@protocol MMInAppChatDelegate
@optional
/// In-app Chat can be disabled or not bind to the application on the Infobip portal. In these cases <code>enabled</code> will be <code>false</code>.
/// You can use this, for example, to show or hide chat button for the user.
- (void)inAppChatIsEnabled:(BOOL)enabled;
/// Called whenever a new chat push message arrives, contains current unread message counter value
- (void)didUpdateUnreadMessagesCounter:(NSInteger)count;
/// Called whenever an attachment exceeds the max allowed size and cannot be uploaded. If undefined, a localised alert will be displayed instead
- (void)attachmentSizeExceeded:(NSUInteger)maxSize;
/// Called whenever a text exceeds the max allowed lenght and cannot be sent.
- (void)textLengthExceeded:(NSUInteger)maxLength;
/// Called for informing about what view the chat is presenting. This is useful if your widget supports multiple
/// threads, in which case you may want to hide the keyboard if something else than the chat view is presented
- (void)chatDidChangeTo:(enum MMChatWebViewState)state;
@end


SWIFT_CLASS("_TtC15MobileMessaging18MMInAppChatService")
@interface MMInAppChatService : MobileMessagingService
/// Method for setting the chat language, both in the WKWebView’s system messages and the inputs. We’ll consider only the left side of a locale and try to recognise the language. If unsupported, English will be set instead. Language must be set before WKWebView is loaded or presented.
- (void)setLanguage:(NSString * _Nonnull)localeString;
@end


SWIFT_CLASS("_TtC15MobileMessaging14MMInAppMessage")
@interface MMInAppMessage : MM_MTMessage
- (nullable instancetype)initWithPayload:(NSDictionary * _Nonnull)payload deliveryMethod:(enum MMMessageDeliveryMethod)deliveryMethod seenDate:(NSDate * _Nullable)seenDate deliveryReportDate:(NSDate * _Nullable)deliveryReportDate seenStatus:(enum MMSeenStatus)seenStatus isDeliveryReportSent:(BOOL)isDeliveryReportSent OBJC_DESIGNATED_INITIALIZER;
@end

typedef SWIFT_ENUM(int16_t, MMInAppNotificationStyle, closed) {
  MMInAppNotificationStyleModal = 0,
  MMInAppNotificationStyleBanner = 1,
};


/// The class encapsulates user inbox data.
SWIFT_CLASS("_TtC15MobileMessaging7MMInbox")
@interface MMInbox : NSObject
/// Total number of messages available in the Inbox. Maximum is limited to 100 messages.
@property (nonatomic) NSInteger countTotal;
/// Number of messages that not yet marked as seen/read. See <code>MobileMessaging.inbox.setSeen(externalUserId:messageIds:completion:)</code>.
@property (nonatomic) NSInteger countUnread;
/// Array of inbox messages ordered by message send date-time.
@property (nonatomic, copy) NSArray<MM_MTMessage *> * _Nonnull messages;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// The class encapsulates filtering options for fetching Inbox messages from server.
/// Always consider narrowing down the scope of messages that need to be fetched as it affects users traffic and networking performance.
SWIFT_CLASS("_TtC15MobileMessaging20MMInboxFilterOptions")
@interface MMInboxFilterOptions : NSObject
@property (nonatomic, readonly, copy) NSDate * _Nullable fromDateTime;
@property (nonatomic, readonly, copy) NSDate * _Nullable toDateTime;
@property (nonatomic, readonly, copy) NSString * _Nullable topic;
- (nonnull instancetype)initWithDictRepresentation:(NSDictionary<NSString *, id> * _Nonnull)dict;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC15MobileMessaging14MMInboxService")
@interface MMInboxService : MobileMessagingService
@end


SWIFT_CLASS("_TtC15MobileMessaging14MMInstallation")
@interface MMInstallation : NSObject <NSCopying, NSSecureCoding>
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
+ (void)setSupportsSecureCoding:(BOOL)value;
@property (nonatomic) NSInteger version;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) NSString * _Nonnull currentPath;)
+ (NSString * _Nonnull)currentPath SWIFT_WARN_UNUSED_RESULT;
+ (void)setCurrentPath:(NSString * _Nonnull)value;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) NSString * _Nonnull dirtyPath;)
+ (NSString * _Nonnull)dirtyPath SWIFT_WARN_UNUSED_RESULT;
+ (void)setDirtyPath:(NSString * _Nonnull)value;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) MMInstallation * _Nonnull empty;)
+ (MMInstallation * _Nonnull)empty SWIFT_WARN_UNUSED_RESULT;
- (void)removeSensitiveData;
- (void)handleCurrentChangesWithOld:(MMInstallation * _Nonnull)old new:(MMInstallation * _Nonnull)new_;
- (void)handleDirtyChangesWithOld:(MMInstallation * _Nonnull)old new:(MMInstallation * _Nonnull)new_;
/// If you have a users database where every user has a unique identifier, you would leverage our External User Id API to gather and link all users devices where your application is installed. However if you have several different applications that share a common user data base you would need to separate one push message destination from another (applications may be considered as destinations here). In order to do such message destination separation, you would need to provide us with a unique Application User Id.
@property (nonatomic, copy) NSString * _Nullable applicationUserId;
/// Returns installations custom data. Arbitrary attributes that are related to the current installation. You can provide additional users information to the server, so that you will be able to send personalised targeted messages to exact user and other nice features.
@property (nonatomic, copy) NSDictionary<NSString *, id <MMAttributeType>> * _Nonnull customAttributes;
/// Primary device setting
/// Single user profile on Infobip Portal can have one or more mobile devices with the application installed. You might want to mark one of such devices as a primary device and send push messages only to this device (i.e. receive bank authorization codes only on one device).
@property (nonatomic) BOOL isPrimaryDevice;
/// Current push registration status.
/// The status defines whether the device is allowed to be receiving push notifications (regular push messages/geofencing campaign messages/messages fetched from the server).
/// MobileMessaging SDK has the push registration enabled by default.
@property (nonatomic) BOOL isPushRegistrationEnabled;
/// Unique push registration identifier issued by server. This identifier matches one to one with APNS cloud token of the particular application installation. This identifier is only available after <code>MMNotificationRegistrationUpdated</code> event.
@property (nonatomic, readonly, copy) NSString * _Nullable pushRegistrationId;
@property (nonatomic, readonly, copy) NSString * _Nullable appVersion;
@property (nonatomic, readonly, copy) NSString * _Nullable deviceManufacturer;
@property (nonatomic, readonly, copy) NSString * _Nullable deviceModel;
@property (nonatomic, readonly, copy) NSString * _Nullable deviceName;
@property (nonatomic, readonly) BOOL deviceSecure;
@property (nonatomic, readonly, copy) NSString * _Nullable deviceTimeZone;
@property (nonatomic, readonly) BOOL geoEnabled;
@property (nonatomic, readonly, copy) NSString * _Nullable language;
@property (nonatomic, readonly, copy) NSString * _Nullable os;
@property (nonatomic, readonly, copy) NSString * _Nullable osVersion;
@property (nonatomic, readonly, copy) NSString * _Nullable pushServiceToken;
@property (nonatomic, readonly, copy) NSString * _Nullable pushServiceType;
@property (nonatomic, readonly, copy) NSString * _Nullable sdkVersion;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nullable instancetype)initWithDictRepresentation:(NSDictionary<NSString *, id> * _Nonnull)dict;
@property (nonatomic, readonly, copy) NSDictionary<NSString *, id> * _Nonnull dictionaryRepresentation;
- (id _Nonnull)copyWithZone:(struct _NSZone * _Nullable)zone SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC15MobileMessaging33MMInteractiveMessageAlertSettings")
@interface MMInteractiveMessageAlertSettings : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) NSString * _Nonnull errorPlaceholderText;)
+ (NSString * _Nonnull)errorPlaceholderText SWIFT_WARN_UNUSED_RESULT;
+ (void)setErrorPlaceholderText:(NSString * _Nonnull)value;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) UIColor * _Nonnull tintColor;)
+ (UIColor * _Nonnull)tintColor SWIFT_WARN_UNUSED_RESULT;
+ (void)setTintColor:(UIColor * _Nonnull)value;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL enabled;)
+ (BOOL)enabled SWIFT_WARN_UNUSED_RESULT;
+ (void)setEnabled:(BOOL)value;
/// cornerRadius is only supported for webInApps
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) float cornerRadius;)
+ (float)cornerRadius SWIFT_WARN_UNUSED_RESULT;
+ (void)setCornerRadius:(float)value;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end



/// Enumerator defining the supported languages of the InAppChat and some string operations and helpers
typedef SWIFT_ENUM(NSInteger, MMLanguage, closed) {
  MMLanguageEn = 0,
  MMLanguageDe = 1,
  MMLanguageTr = 2,
  MMLanguageKo = 3,
  MMLanguageRu = 4,
  MMLanguageJa = 5,
  MMLanguageZhHans = 6,
  MMLanguageZhHant = 7,
  MMLanguageEs = 8,
  MMLanguagePt = 9,
  MMLanguagePl = 10,
  MMLanguageRo = 11,
  MMLanguageAr = 12,
  MMLanguageBs = 13,
  MMLanguageHr = 14,
  MMLanguageEl = 15,
  MMLanguageSv = 16,
  MMLanguageTh = 17,
  MMLanguageLt = 18,
  MMLanguageDa = 19,
  MMLanguageLv = 20,
  MMLanguageHu = 21,
  MMLanguageIt = 22,
  MMLanguageFr = 23,
  MMLanguageSl = 24,
  MMLanguageUk = 25,
  MMLanguageSq = 26,
  MMLanguageSr = 27,
};


/// Describes the kind of location service. Possible values:
/// <ul>
///   <li>
///     Location Updates
///   </li>
///   <li>
///     Region Monitoring
///   </li>
/// </ul>
SWIFT_CLASS("_TtC15MobileMessaging21MMLocationServiceKind")
@interface MMLocationServiceKind : NSObject
- (nonnull instancetype)initWithOptions:(NSArray<MMLocationServiceKind *> * _Nonnull)options OBJC_DESIGNATED_INITIALIZER;
- (BOOL)containsWithOptions:(MMLocationServiceKind * _Nonnull)options SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) MMLocationServiceKind * _Nonnull locationUpdates;)
+ (MMLocationServiceKind * _Nonnull)locationUpdates SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) MMLocationServiceKind * _Nonnull regionMonitoring;)
+ (MMLocationServiceKind * _Nonnull)regionMonitoring SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// Describes the usage type for the location service. Possible values:
/// <ul>
///   <li>
///     When in Use
///   </li>
///   <li>
///     Always
///   </li>
/// </ul>
typedef SWIFT_ENUM(NSInteger, MMLocationServiceUsage, closed) {
/// This app is authorized to start most location services while running in the foreground.
  MMLocationServiceUsageWhenInUse = 0,
/// This app is authorized to start location services at any time.
  MMLocationServiceUsageAlways = 1,
};

typedef SWIFT_ENUM(NSUInteger, MMLogLevel, closed) {
/// <ul>
///   <li>
///     No logs
///   </li>
/// </ul>
  MMLogLevelOff = 0,
/// <ul>
///   <li>
///     Error logs only
///   </li>
/// </ul>
  MMLogLevelError = 1,
/// <ul>
///   <li>
///     Error and warning logs
///   </li>
/// </ul>
  MMLogLevelWarning = 2,
/// <ul>
///   <li>
///     Error, warning and info logs
///   </li>
/// </ul>
  MMLogLevelInfo = 3,
/// <ul>
///   <li>
///     Error, warning, info and debug logs
///   </li>
/// </ul>
  MMLogLevelDebug = 4,
/// <ul>
///   <li>
///     Error, warning, info, debug and verbose logs
///   </li>
/// </ul>
  MMLogLevelVerbose = 5,
  MMLogLevelAll = 6,
};


SWIFT_CLASS("_TtC15MobileMessaging11MMLogOutput")
@interface MMLogOutput : NSObject
- (nonnull instancetype)initWithOptions:(NSArray<MMLogOutput *> * _Nonnull)options OBJC_DESIGNATED_INITIALIZER;
- (BOOL)containsWithOptions:(MMLogOutput * _Nonnull)options SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) MMLogOutput * _Nonnull None;)
+ (MMLogOutput * _Nonnull)None SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) MMLogOutput * _Nonnull Console;)
+ (MMLogOutput * _Nonnull)Console SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) MMLogOutput * _Nonnull ASL;)
+ (MMLogOutput * _Nonnull)ASL SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) MMLogOutput * _Nonnull File;)
+ (MMLogOutput * _Nonnull)File SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC15MobileMessaging15MMLoggerFactory")
@interface MMLoggerFactory : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end



typedef SWIFT_ENUM(int16_t, MMMessageDeliveryMethod, closed) {
  MMMessageDeliveryMethodUndefined = 0,
  MMMessageDeliveryMethodPush = 1,
  MMMessageDeliveryMethodPull = 2,
  MMMessageDeliveryMethodGeneratedLocally = 3,
  MMMessageDeliveryMethodLocal = 4,
};

typedef SWIFT_ENUM(int16_t, MMMessageDirection, closed) {
  MMMessageDirectionMT = 0,
  MMMessageDirectionMO = 1,
};


SWIFT_CLASS("_TtC15MobileMessaging16MMMessageHandler")
@interface MMMessageHandler : MobileMessagingService
@end

@class UNNotification;
@class MMUserNotificationType;
@class MMWebViewController;

SWIFT_PROTOCOL("_TtP15MobileMessaging25MMMessageHandlingDelegate_")
@protocol MMMessageHandlingDelegate
@optional
/// Called when a new message is received.
/// \param message the new message received
///
- (void)didReceiveNewMessageWithMessage:(MM_MTMessage * _Nonnull)message;
/// Called when a notification is delivered to a foreground app.
/// If your app is in the foreground when a notification arrives, the MobileMessaging SDK calls this method to deliver the notification directly to your app. If you implement this method, you can take whatever actions are necessary to process the notification and update your app. When you finish, execute the completionHandler block and specify how you want the system to alert the user, if at all.
- (void)willPresentInForegroundWithMessage:(MM_MTMessage * _Nullable)message notification:(UNNotification * _Nonnull)notification withCompletionHandler:(void (^ _Nonnull)(MMUserNotificationType * _Nonnull))completionHandler;
/// Called when a local notification scheduled for a message. Apart from push messages that are pushed to the device by APNs and displayed by iOS automatically, MobileMessaging SDK delivers messages by pulling them from the server and generating them locally. These messages are displayed via Local Notifications.
- (void)willScheduleLocalNotificationFor:(MM_MTMessage * _Nonnull)message;
/// Called when a notification action is performed by the user.
/// \param action <code>MMNotificationAction</code> object defining the action which was triggered.
///
/// \param message <code>MM_MTMessage</code> message, for which action button was displayed, you can use <code>message.categoryId</code> in order to check the categoryId for action.
///
/// \param notificationUserInfo a dictionary representing original local/remote notification’s userInfo
///
/// \param completion The block to execute when specified action performing is finished. <em>You must call this block either immediately or after your handling is completed.</em> The block is originally passed to <code>UNUserNotificationCenterDelegate</code>’s <code>userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -> Swift.Void)</code> callback as a <code>completionHandler</code> parameter.
///
- (void)didPerformWithAction:(MMNotificationAction * _Nonnull)action forMessage:(MM_MTMessage * _Nullable)message notificationUserInfo:(NSDictionary<NSString *, id> * _Nullable)notificationUserInfo completion:(void (^ _Nonnull)(void))completion;
/// Called when a web view is about to be shown. It’s required to provide a view controller that will present the web view.
/// \param message <code>MM_MTMessage</code> object, that has a special URL (see <code>webViewUrl</code> property) to be opened in the web view.
///
///
/// returns:
/// Parent view controller that would be used to present the web view. If you return <code>nil</code>, the web view would not be shown up.
- (UIViewController * _Nullable)inAppWebViewPresentingViewControllerFor:(MM_MTMessage * _Nonnull)message SWIFT_WARN_UNUSED_RESULT SWIFT_UNAVAILABLE_MSG("'inAppWebViewPresentingViewController' has been renamed to 'inAppPresentingViewControllerFor:': The method is unavailable. Please, use `inAppPresentingViewController(for:)` instead.");
/// Called when a web view is about to be shown. This callback is intended to be the customization point for WebViewController. You are able to customize WebViewController’s behaviour and appearance within this callback implementation.
/// <ul>
///   <li>
///     message: <code>MM_MTMessage</code> object, that has a special URL (see <code>webViewUrl</code> property) to be opened in the web view.
///   </li>
/// </ul>
/// \param webViewController A ViewController that is responsible for displaying the web view.
///
- (void)inAppWebViewWillShowUp:(MMWebViewController * _Nonnull)webViewController for:(MM_MTMessage * _Nonnull)message;
/// Called when an in-app notification or in-app web view is about to be shown. It’s required to provide a view controller that will present in-app notification or in-app web view. Do not implement this method, if you want to leave default behaviour, by default topmost visible view controller will be used.
/// \param message <code>MM_MTMessage</code> object
///
///
/// returns:
/// Parent view controller that would be used to present an in-app notification or in-app web view.
- (UIViewController * _Nullable)inAppPresentingViewControllerFor:(MM_MTMessage * _Nonnull)message SWIFT_WARN_UNUSED_RESULT;
/// Called when a <code>MODAL</code> in-app notification for provided message is ready to be shown. Returns a Boolean value indicating whether a <code>MODAL</code> in-app notification be displayed or not.
/// \param message <code>MM_MTMessage</code> object for in-app notification.
///
///
/// returns:
/// Boolean value indicating should or shouldn’t <code>MODAL</code> In-app notification be displayed.
- (BOOL)shouldShowModalInAppNotificationFor:(MM_MTMessage * _Nonnull)message SWIFT_WARN_UNUSED_RESULT;
/// Called when the tapped notification contains a browserURL. Returns a Boolean value indicating whether the URL will be open in the browser or not.
/// \param url <code>URL</code> received in the tapped notification.
///
///
/// returns:
/// Boolean value indicating should or shouldn’t open the URL in the mobile’s browser.
- (BOOL)shouldOpenInBrowser:(NSURL * _Nonnull)url SWIFT_WARN_UNUSED_RESULT;
@end



SWIFT_PROTOCOL("_TtP15MobileMessaging24MMMessageStorageDelegate_")
@protocol MMMessageStorageDelegate
- (void)didInsertNewMessages:(NSArray<MMBaseMessage *> * _Nonnull)messages;
- (void)didUpdateMessage:(MMBaseMessage * _Nonnull)message;
- (void)didRemoveMessages:(NSArray<MMBaseMessage *> * _Nonnull)messages;
@end




@class MMNotificationActionOptions;

SWIFT_CLASS("_TtC15MobileMessaging20MMNotificationAction")
@interface MMNotificationAction : NSObject
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull DismissActionId;)
+ (NSString * _Nonnull)DismissActionId SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull DefaultActionId;)
+ (NSString * _Nonnull)DefaultActionId SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull PrimaryActionId;)
+ (NSString * _Nonnull)PrimaryActionId SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly, copy) NSString * _Nonnull identifier;
@property (nonatomic, readonly, copy) NSString * _Nonnull title;
@property (nonatomic, readonly, copy) NSArray<MMNotificationActionOptions *> * _Nonnull options;
@property (nonatomic, readonly) BOOL isTapOnNotificationAlert;
/// Initializes the <code>MMNotificationAction</code>
/// \param identifier action identifier. “mm_” prefix is reserved for Mobile Messaging ids and cannot be used as a prefix.
///
/// \param title Title of the button which will be displayed.
///
/// \param options Options with which to perform the action.
///
- (nullable instancetype)initWithIdentifier:(NSString * _Nonnull)identifier title:(NSString * _Nonnull)title options:(NSArray<MMNotificationActionOptions *> * _Nullable)options;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC15MobileMessaging27MMNotificationActionOptions")
@interface MMNotificationActionOptions : NSObject
- (nonnull instancetype)initWithOptions:(NSArray<MMNotificationActionOptions *> * _Nonnull)options OBJC_DESIGNATED_INITIALIZER;
- (BOOL)containsWithOptions:(MMLogOutput * _Nonnull)options SWIFT_WARN_UNUSED_RESULT;
/// Causes the launch of the application.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) MMNotificationActionOptions * _Nonnull foreground;)
+ (MMNotificationActionOptions * _Nonnull)foreground SWIFT_WARN_UNUSED_RESULT;
/// Marks the action button as destructive.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) MMNotificationActionOptions * _Nonnull destructive;)
+ (MMNotificationActionOptions * _Nonnull)destructive SWIFT_WARN_UNUSED_RESULT;
/// Requires the device to be unlocked.
/// remark:
/// If the action options contains <code>.foreground</code>, then the action is considered as requiring authentication automatically.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) MMNotificationActionOptions * _Nonnull authenticationRequired;)
+ (MMNotificationActionOptions * _Nonnull)authenticationRequired SWIFT_WARN_UNUSED_RESULT;
/// Indicates whether the SDK must generate MO message to report on users interaction.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) MMNotificationActionOptions * _Nonnull moRequired;)
+ (MMNotificationActionOptions * _Nonnull)moRequired SWIFT_WARN_UNUSED_RESULT;
/// Indicates whether action is compatible with chat messages. If it is compatible, the action button will be shown in the SDK buil-in chat view.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) MMNotificationActionOptions * _Nonnull chatCompatible;)
+ (MMNotificationActionOptions * _Nonnull)chatCompatible SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class MMNotificationCategoryOptions;

SWIFT_CLASS("_TtC15MobileMessaging22MMNotificationCategory")
@interface MMNotificationCategory : NSObject
/// The category identifier passed in a <code>MM_MTMessage</code> object
@property (nonatomic, readonly, copy) NSString * _Nonnull identifier;
/// Actions in the order to be displayed for available contexts.
/// remark:
/// If there are more than four action objects in the array, the notification displays only the first four. When displaying banner notifications, the system displays only the first two actions.
@property (nonatomic, readonly, copy) NSArray<MMNotificationAction *> * _Nonnull actions;
/// Options indicating how to handle notifications associated with category.
@property (nonatomic, readonly, copy) NSArray<MMNotificationCategoryOptions *> * _Nonnull options;
/// The intent identifier strings, which defined in Intents framework, that you want to associate with notifications of this category.
/// remark:
/// Intent identifier may be useful for SiriKit support.
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nonnull intentIdentifiers;
/// Initializes the <code>MMNotificationCategory</code>
/// \param identifier category identifier. “mm_” prefix is reserved for Mobile Messaging ids and cannot be used as a prefix.
///
/// \param actions Actions in the order to be displayed for available contexts.
///
/// \param options Options indicating how to handle notifications associated with category. Supported only for iOS 10+.
///
/// \param intentIdentifiers The intent identifier strings, which defined in Intents framework, that you want to associate with notifications of this category. Supported only for iOS 10+.
///
- (nullable instancetype)initWithIdentifier:(NSString * _Nonnull)identifier actions:(NSArray<MMNotificationAction *> * _Nonnull)actions options:(NSArray<MMNotificationCategoryOptions *> * _Nullable)options intentIdentifiers:(NSArray<NSString *> * _Nullable)intentIdentifiers OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithDictionary:(NSDictionary<NSString *, id> * _Nonnull)dictionary OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC15MobileMessaging29MMNotificationCategoryOptions")
@interface MMNotificationCategoryOptions : NSObject
- (nonnull instancetype)initWithOptions:(NSArray<MMNotificationCategoryOptions *> * _Nonnull)options OBJC_DESIGNATED_INITIALIZER;
- (BOOL)containsWithOptions:(MMNotificationCategoryOptions * _Nonnull)options SWIFT_WARN_UNUSED_RESULT;
/// remark:
/// This option is available only for iOS 10+
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) MMNotificationCategoryOptions * _Nonnull allowInCarPlay;)
+ (MMNotificationCategoryOptions * _Nonnull)allowInCarPlay SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC15MobileMessaging11MMOperation")
@interface MMOperation : Operation
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// <code>OperationQueue</code> is an <code>NSOperationQueue</code> subclass that implements a large
/// number of “extra features” related to the <code>Operation</code> class:
/// <ul>
///   <li>
///     Notifying a delegate of all operation completion
///   </li>
///   <li>
///     Extracting generated dependencies from operation conditions
///   </li>
///   <li>
///     Setting up dependencies to enforce mutual exclusivity
///   </li>
/// </ul>
SWIFT_CLASS("_TtC15MobileMessaging14OperationQueue")
@interface OperationQueue : NSOperationQueue
- (void)addOperation:(NSOperation * _Nonnull)operation;
- (void)addOperations:(NSArray<NSOperation *> * _Nonnull)ops waitUntilFinished:(BOOL)wait;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC15MobileMessaging16MMOperationQueue")
@interface MMOperationQueue : OperationQueue
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC15MobileMessaging7MMPhone")
@interface MMPhone : NSObject <NSSecureCoding>
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
+ (void)setSupportsSecureCoding:(BOOL)value;
@property (nonatomic, readonly, copy) NSString * _Nonnull number;
@property (nonatomic) BOOL preferred;
- (nullable instancetype)initWithDictRepresentation:(NSDictionary<NSString *, id> * _Nonnull)dict OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, readonly, copy) NSDictionary<NSString *, id> * _Nonnull dictionaryRepresentation;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)initWithNumber:(NSString * _Nonnull)number preferred:(BOOL)preferred OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC15MobileMessaging11MMPostponer")
@interface MMPostponer : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// The <code>MMPrivacySettings</code> class encapsulates privacy settings that affect the SDK behaviour and business logic.
SWIFT_CLASS("_TtC15MobileMessaging17MMPrivacySettings")
@interface MMPrivacySettings : NSObject
/// A boolean variable that indicates whether the MobileMessaging SDK will be sending the carrier information to the server.
/// Default value is <code>false</code>.
@property (nonatomic) BOOL carrierInfoSendingDisabled;
/// A boolean variable that indicates whether the MobileMessaging SDK will be sending the system information such as OS version, device model, application version to the server.
/// Default value is <code>false</code>.
@property (nonatomic) BOOL systemInfoSendingDisabled;
/// A boolean variable that indicates whether the MobileMessaging SDK will be persisting the application code locally. This feature is a convenience to maintain SDK viability during debugging and possible application code changes.
/// Default value is <code>false</code>.
/// warning:
/// there might be situation when you want to switch between different Application Codes during development/testing. If you disable the application code persisting (value <code>true</code>), the SDK won’t detect the application code changes, thus won’t cleanup the old application code related data. You should manually invoke <code>MobileMessaging.cleanUpAndStop()</code> prior to start otherwise the SDK would not detect the application code change.
@property (nonatomic) BOOL applicationCodePersistingDisabled;
/// A boolean variable that indicates whether the MobileMessaging SDK will be persisting the user data locally. Persisting user data locally gives you quick access to the data and eliminates a need to implement it yourself.
/// Default value is <code>false</code>.
@property (nonatomic) BOOL userDataPersistingDisabled;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class NSPredicate;
@class NSSortDescriptor;

/// The class defines a query that is used to fetch messages from the Message Storage.
SWIFT_CLASS("_TtC15MobileMessaging7MMQuery")
@interface MMQuery : NSObject
/// note:
///
/// The following types of predicates are supported:
/// <ul>
///   <li>
///     Simple comparisons such as <code>=</code>, <code>!=</code>, <code><</code>, <code>></code>, <code><=</code>, <code>>=</code>, and <code>BETWEEN</code> with a key and a constant.
///   </li>
///   <li>
///     Containment predicates, such as <code>x IN {1, 2, 3}</code>.
///   </li>
///   <li>
///     Key-existence predicates, such as <code>x IN SELF</code>.
///   </li>
///   <li>
///     <code>BEGINSWITH</code> expressions.
///   </li>
///   <li>
///     Compound predicates with <code>AND</code>, <code>OR</code>, and <code>NOT</code>.
///   </li>
///   <li>
///     SubQueries with key IN %@, subquery.
///   </li>
/// </ul>
/// The following types of predicates are NOT supported:
/// <ul>
///   <li>
///     Aggregate operations, such as <code>ANY</code>, <code>SOME</code>, <code>ALL</code>, or <code>NONE</code>.
///   </li>
///   <li>
///     Regular expressions, such as <code>LIKE</code>, <code>MATCHES</code>, <code>CONTAINS</code>, or <code>ENDSWITH</code>.
///   </li>
///   <li>
///     Predicates comparing one key to another.
///   </li>
///   <li>
///     Complex predicates with many ORed clauses.
///   </li>
/// </ul>
@property (nonatomic, strong) NSPredicate * _Nullable predicate;
/// An array of <code>NSSortDescriptor</code> objects to use to sort the results of the query.
@property (nonatomic, copy) NSArray<NSSortDescriptor *> * _Nullable sortDescriptors;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class CLCircularRegion;

SWIFT_CLASS("_TtC15MobileMessaging8MMRegion")
@interface MMRegion : NSObject
@property (nonatomic, readonly, copy) NSString * _Nonnull identifier;
@property (nonatomic, readonly) CLLocationCoordinate2D center;
@property (nonatomic, readonly) double radius;
@property (nonatomic, readonly, copy) NSString * _Nonnull title;
@property (nonatomic, readonly, strong) CLCircularRegion * _Nonnull circularRegion;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nullable instancetype)initWithDictRepresentation:(NSDictionary<NSString *, id> * _Nonnull)dict;
@property (nonatomic, readonly, copy) NSDictionary<NSString *, id> * _Nonnull dictionaryRepresentation;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

typedef SWIFT_ENUM(int16_t, MMSeenStatus, closed) {
  MMSeenStatusNotSeen = 0,
  MMSeenStatusSeenNotSent = 1,
  MMSeenStatusSeenSent = 2,
};

typedef SWIFT_ENUM(NSInteger, MMSuccessPending, closed) {
  MMSuccessPendingUndefined = 0,
  MMSuccessPendingPending = 1,
  MMSuccessPendingSuccess = 2,
};


/// Allows text input from the user
SWIFT_CLASS("_TtC15MobileMessaging29MMTextInputNotificationAction")
@interface MMTextInputNotificationAction : MMNotificationAction
@property (nonatomic, readonly, copy) NSString * _Nonnull textInputActionButtonTitle;
@property (nonatomic, readonly, copy) NSString * _Nonnull textInputPlaceholder;
/// Text which was entered in response to action.
@property (nonatomic, copy) NSString * _Nullable typedText;
/// Initializes the <code>TextInputNotificationAction</code>
/// \param identifier action identifier. “mm_” prefix is reserved for Mobile Messaging ids and cannot be used as a prefix.
///
/// \param title Title of the button which will be displayed.
///
/// \param options Options with which to perform the action.
///
/// \param textInputActionButtonTitle Title of the text input action button
///
/// \param textInputPlaceholder Placeholder in the text input field.
///
- (nullable instancetype)initWithIdentifier:(NSString * _Nonnull)identifier title:(NSString * _Nonnull)title options:(NSArray<MMNotificationActionOptions *> * _Nullable)options textInputActionButtonTitle:(NSString * _Nonnull)textInputActionButtonTitle textInputPlaceholder:(NSString * _Nonnull)textInputPlaceholder OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC15MobileMessaging16MMUserAttributes")
@interface MMUserAttributes : NSObject
/// The user’s first name. You can provide additional users information to the server, so that you will be able to send personalised targeted messages to exact user and other nice features.
@property (nonatomic, copy) NSString * _Nullable firstName;
/// A user’s middle name. You can provide additional users information to the server, so that you will be able to send personalised targeted messages to exact user and other nice features.
@property (nonatomic, copy) NSString * _Nullable middleName;
/// A user’s last name. You can provide additional users information to the server, so that you will be able to send personalised targeted messages to exact user and other nice features.
@property (nonatomic, copy) NSString * _Nullable lastName;
/// A user’s tags. You can provide additional users information to the server, so that you will be able to send personalised targeted messages to exact user and other nice features.
@property (nonatomic, copy) NSSet<NSString *> * _Nullable tags;
@property (nonatomic) enum MMGenderNonnull genderNonnull;
/// A user’s birthday. You can provide additional users information to the server, so that you will be able to send personalised targeted messages to exact user and other nice features.
@property (nonatomic, copy) NSDate * _Nullable birthday;
/// Returns user’s custom data. Arbitrary attributes that are related to a particular user. You can provide additional users information to the server, so that you will be able to send personalised targeted messages to exact user and other nice features.
@property (nonatomic, copy) NSDictionary<NSString *, id <MMAttributeType>> * _Nullable customAttributes;
- (nonnull instancetype)initWithFirstName:(NSString * _Nullable)firstName middleName:(NSString * _Nullable)middleName lastName:(NSString * _Nullable)lastName tags:(NSSet<NSString *> * _Nullable)tags genderNonnull:(enum MMGenderNonnull)genderNonnull birthday:(NSDate * _Nullable)birthday customAttributes:(NSDictionary<NSString *, id <MMAttributeType>> * _Nullable)customAttributes;
- (nullable instancetype)initWithDictRepresentation:(NSDictionary<NSString *, id> * _Nonnull)dict;
@property (nonatomic, readonly, copy) NSDictionary<NSString *, id> * _Nonnull dictionaryRepresentation;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC15MobileMessaging6MMUser")
@interface MMUser : MMUserAttributes <NSCopying, NSSecureCoding>
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) BOOL supportsSecureCoding;)
+ (BOOL)supportsSecureCoding SWIFT_WARN_UNUSED_RESULT;
+ (void)setSupportsSecureCoding:(BOOL)value;
@property (nonatomic) NSInteger version;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) NSString * _Nonnull currentPath;)
+ (NSString * _Nonnull)currentPath SWIFT_WARN_UNUSED_RESULT;
+ (void)setCurrentPath:(NSString * _Nonnull)value;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) NSString * _Nonnull dirtyPath;)
+ (NSString * _Nonnull)dirtyPath SWIFT_WARN_UNUSED_RESULT;
+ (void)setDirtyPath:(NSString * _Nonnull)value;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) MMUser * _Nonnull empty;)
+ (MMUser * _Nonnull)empty SWIFT_WARN_UNUSED_RESULT;
- (void)removeSensitiveData;
- (void)handleCurrentChangesWithOld:(MMUser * _Nonnull)old new:(MMUser * _Nonnull)new_;
- (void)handleDirtyChangesWithOld:(MMUser * _Nonnull)old new:(MMUser * _Nonnull)new_;
/// The user’s id you can provide in order to link your own unique user identifier with Mobile Messaging user id, so that you will be able to send personalised targeted messages to exact user and other nice features.
@property (nonatomic, copy) NSString * _Nullable externalUserId;
/// User’s phone numbers. You can provide additional users information to the server, so that you will be able to send personalised targeted messages to exact user and other nice features.
@property (nonatomic, copy) NSArray<NSString *> * _Nullable phones;
/// User’s email addresses. You can provide additional users information to the server, so that you will be able to send personalised targeted messages to exact user and other nice features.
@property (nonatomic, copy) NSArray<NSString *> * _Nullable emails;
/// All installations personalized with the user
@property (nonatomic, readonly, copy) NSArray<MMInstallation *> * _Nullable installations;
- (nullable instancetype)initWithDictRepresentation:(NSDictionary<NSString *, id> * _Nonnull)dict;
@property (nonatomic, readonly, copy) NSDictionary<NSString *, id> * _Nonnull dictionaryRepresentation;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
- (void)encodeWithCoder:(NSCoder * _Nonnull)aCoder;
- (id _Nonnull)copyWithZone:(struct _NSZone * _Nullable)zone SWIFT_WARN_UNUSED_RESULT;
@end


SWIFT_CLASS("_TtC15MobileMessaging11MMUserAgent")
@interface MMUserAgent : NSObject
@property (nonatomic, copy) NSString * _Nullable pluginVersion;
@property (nonatomic, readonly, copy) NSString * _Nonnull language;
@property (nonatomic, readonly, copy) NSString * _Nonnull osVersion;
@property (nonatomic, readonly, copy) NSString * _Nonnull osName;
@property (nonatomic, readonly, copy) NSString * _Nonnull libraryVersion;
@property (nonatomic, readonly, copy) NSString * _Nonnull libraryName;
@property (nonatomic, readonly, copy) NSString * _Nonnull hostingAppVersion;
@property (nonatomic, readonly, copy) NSString * _Nonnull hostingAppName;
@property (nonatomic, readonly, copy) NSString * _Nonnull deviceManufacturer;
@property (nonatomic, readonly, copy) NSString * _Nonnull deviceName;
@property (nonatomic, readonly, copy) NSString * _Nonnull deviceModelName;
@property (nonatomic, readonly) BOOL deviceSecure;
@property (nonatomic, readonly, copy) NSString * _Nullable deviceTimeZone;
@property (nonatomic, readonly, copy) NSString * _Nonnull pushServiceType;
@property (nonatomic, readonly, copy) NSString * _Nonnull currentUserAgentString;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end



SWIFT_CLASS("_TtC15MobileMessaging14MMUserIdentity")
@interface MMUserIdentity : NSObject
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nullable phones;
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nullable emails;
@property (nonatomic, readonly, copy) NSString * _Nullable externalUserId;
/// Default initializer. The object won’t be initialized if all three arguments are nil/empty. Unique user identity must have at least one value.
- (nullable instancetype)initWithPhones:(NSArray<NSString *> * _Nullable)phones emails:(NSArray<NSString *> * _Nullable)emails externalUserId:(NSString * _Nullable)externalUserId OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC15MobileMessaging22MMUserNotificationType")
@interface MMUserNotificationType : NSObject
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)initWithOptions:(NSArray<MMUserNotificationType *> * _Nonnull)options OBJC_DESIGNATED_INITIALIZER;
- (BOOL)containsWithOptions:(MMUserNotificationType * _Nonnull)options SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) MMUserNotificationType * _Nonnull none;)
+ (MMUserNotificationType * _Nonnull)none SWIFT_WARN_UNUSED_RESULT;
/// The ability to display alerts.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) MMUserNotificationType * _Nonnull alert;)
+ (MMUserNotificationType * _Nonnull)alert SWIFT_WARN_UNUSED_RESULT;
/// The ability to update the app’s badge.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) MMUserNotificationType * _Nonnull badge;)
+ (MMUserNotificationType * _Nonnull)badge SWIFT_WARN_UNUSED_RESULT;
/// The ability to play sounds.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) MMUserNotificationType * _Nonnull sound;)
+ (MMUserNotificationType * _Nonnull)sound SWIFT_WARN_UNUSED_RESULT;
/// The ability to display notifications in a CarPlay environment.
/// remark:
/// This option is available only for iOS 10+
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) MMUserNotificationType * _Nonnull carPlay;)
+ (MMUserNotificationType * _Nonnull)carPlay SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC15MobileMessaging19MMWebViewController")
@interface MMWebViewController : UINavigationController
- (nonnull instancetype)initWithNibName:(NSString * _Nullable)nibNameOrNil bundle:(NSBundle * _Nullable)nibBundleOrNil SWIFT_UNAVAILABLE;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder SWIFT_UNAVAILABLE;
@property (nonatomic, copy) NSString * _Nullable title;
- (nonnull instancetype)initWithNavigationBarClass:(Class _Nullable)navigationBarClass toolbarClass:(Class _Nullable)toolbarClass SWIFT_UNAVAILABLE;
- (nonnull instancetype)initWithRootViewController:(UIViewController * _Nonnull)rootViewController SWIFT_UNAVAILABLE;
@end


SWIFT_CLASS("_TtC15MobileMessaging23MMWebViewControllerBase")
@interface MMWebViewControllerBase : UIViewController <WKNavigationDelegate>
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder SWIFT_UNAVAILABLE;
- (void)viewDidLoad;
- (void)viewDidLayoutSubviews;
- (void)observeValueForKeyPath:(NSString * _Nullable)keyPath ofObject:(id _Nullable)object change:(NSDictionary<NSKeyValueChangeKey, id> * _Nullable)change context:(void * _Nullable)context;
- (void)viewWillAppear:(BOOL)animated;
- (void)webView:(WKWebView * _Nonnull)webView didFailNavigation:(WKNavigation * _Null_unspecified)navigation withError:(NSError * _Nonnull)error;
- (void)webView:(WKWebView * _Nonnull)webView didFailProvisionalNavigation:(WKNavigation * _Null_unspecified)navigation withError:(NSError * _Nonnull)error;
- (void)webView:(WKWebView * _Nonnull)webView didFinishNavigation:(WKNavigation * _Null_unspecified)navigation;
- (void)webView:(WKWebView * _Nonnull)webView decidePolicyForNavigationAction:(WKNavigationAction * _Nonnull)navigationAction decisionHandler:(void (^ _Nonnull)(WKNavigationActionPolicy))decisionHandler;
- (nonnull instancetype)initWithNibName:(NSString * _Nullable)nibNameOrNil bundle:(NSBundle * _Nullable)nibBundleOrNil SWIFT_UNAVAILABLE;
@end


SWIFT_CLASS("_TtC15MobileMessaging17MMWebViewSettings")
@interface MMWebViewSettings : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end



SWIFT_CLASS("_TtC15MobileMessaging12MM_MOMessage")
@interface MM_MOMessage : MMBaseMessage
/// Destination indicates where the message is being sent
@property (nonatomic, copy) NSString * _Nullable destination;
/// Sent status
@property (nonatomic) enum MM_MOMessageSentStatus sentStatus;
/// Indicates when the message was composed
@property (nonatomic, copy) NSDate * _Nonnull composedDate;
/// Indicates the bulk id that the message was sent within
@property (nonatomic, copy) NSString * _Nullable bulkId;
/// Indicates id of the associated message
@property (nonatomic, copy) NSString * _Nullable initialMessageId;
- (nonnull instancetype)initWithDestination:(NSString * _Nullable)destination text:(NSString * _Nonnull)text customPayload:(NSDictionary<NSString *, id> * _Nullable)customPayload composedDate:(NSDate * _Nonnull)composedDate bulkId:(NSString * _Nullable)bulkId initialMessageId:(NSString * _Nullable)initialMessageId;
- (nonnull instancetype)initWithMessageId:(NSString * _Nonnull)messageId direction:(enum MMMessageDirection)direction originalPayload:(NSDictionary<NSString *, id> * _Nonnull)originalPayload deliveryMethod:(enum MMMessageDeliveryMethod)deliveryMethod SWIFT_UNAVAILABLE;
@end

typedef SWIFT_ENUM(int16_t, MM_MOMessageSentStatus, closed) {
  MM_MOMessageSentStatusUndefined = -1,
  MM_MOMessageSentStatusSentSuccessfully = 0,
  MM_MOMessageSentStatusSentWithFailure = 1,
};








SWIFT_CLASS_NAMED("Message")
@interface Message : NSManagedObject
- (nonnull instancetype)initWithEntity:(NSEntityDescription * _Nonnull)entity insertIntoManagedObjectContext:(NSManagedObjectContext * _Nullable)context OBJC_DESIGNATED_INITIALIZER;
@end



@interface Message (SWIFT_EXTENSION(MobileMessaging))
@property (nonatomic, copy) NSString * _Nonnull messageId;
@property (nonatomic, copy) NSDictionary<NSString *, id> * _Nonnull payload;
@property (nonatomic) BOOL isDeliveryReportSent;
@property (nonatomic) int16_t seenStatusValue;
@property (nonatomic, copy) NSDate * _Nonnull createdDate;
@property (nonatomic) int16_t deliveryMethod;
@property (nonatomic) int16_t direction;
@property (nonatomic) int16_t sentStatusValue;
@property (nonatomic, copy) NSDate * _Nullable deliveryReportedDate;
@property (nonatomic, copy) NSDate * _Nullable seenDate;
@end


SWIFT_CLASS_NAMED("MessageManagedObject")
@interface MessageManagedObject : NSManagedObject
- (nonnull instancetype)initWithEntity:(NSEntityDescription * _Nonnull)entity insertIntoManagedObjectContext:(NSManagedObjectContext * _Nullable)context OBJC_DESIGNATED_INITIALIZER;
@end


@interface MessageManagedObject (SWIFT_EXTENSION(MobileMessaging))
@property (nonatomic, copy) NSDate * _Nonnull creationDate;
@property (nonatomic, copy) NSString * _Nonnull messageId;
@property (nonatomic) BOOL reportSent;
@property (nonatomic, copy) NSDate * _Nullable seenDate;
@property (nonatomic, copy) NSDictionary<NSString *, id> * _Nullable payload;
@property (nonatomic) int16_t messageTypeValue;
@property (nonatomic) int16_t seenStatusValue;
@property (nonatomic) BOOL isSilent;
@property (nonatomic) int16_t campaignStateValue;
@property (nonatomic, copy) NSString * _Nullable campaignId;
@property (nonatomic, copy) NSDate * _Nullable deliveryReportedDate;
@property (nonatomic) int16_t deliveryMethod;
@end

@class NSData;
@class NSURLSessionConfiguration;
@class NSTimeZone;
@class NSCalendar;

SWIFT_CLASS("_TtC15MobileMessaging15MobileMessaging")
@interface MobileMessaging : NSObject
/// Fabric method for Mobile Messaging session.
/// \param code The application code of your Application from Push Portal website.
///
/// \param notificationType Preferable notification types that indicating how the app alerts the user when a push notification arrives.
///
+ (MobileMessaging * _Nullable)withApplicationCode:(NSString * _Nonnull)code notificationType:(MMUserNotificationType * _Nonnull)notificationType SWIFT_WARN_UNUSED_RESULT;
/// Fabric method for Mobile Messaging session.
/// warning:
/// The cleanup (parameter <code>forceCleanup = true</code>) must be performed manually if you changed the application code while <code>PrivacySettings.applicationCodePersistingDisabled</code> is set to <code>true</code>.
/// \param code The application code of your Application from Push Portal website.
///
/// \param notificationType Preferable notification types that indicating how the app alerts the user when a push notification arrives.
///
/// \param forceCleanup Defines whether the SDK must be cleaned up on startup.
///
+ (MobileMessaging * _Nullable)withApplicationCode:(NSString * _Nonnull)code notificationType:(MMUserNotificationType * _Nonnull)notificationType forceCleanup:(BOOL)forceCleanup SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_MSG("The function is deprecated. `forceCleanup` argument is always considered false, however we detect app code change and cleanup SDK data for you.");
/// Fabric method for Mobile Messaging session.
/// \param notificationType Preferable notification types that indicating how the app alerts the user when a push notification arrives.
///
/// \param code The application code of your Application from Push Portal website.
///
/// \param backendBaseURL Your backend server base URL, optional parameter. Default is https://oneapi.infobip.com.
///
+ (MobileMessaging * _Nullable)withApplicationCode:(NSString * _Nonnull)code notificationType:(MMUserNotificationType * _Nonnull)notificationType backendBaseURL:(NSString * _Nonnull)backendBaseURL SWIFT_WARN_UNUSED_RESULT;
/// Fabric method for Mobile Messaging session.
/// It is possible to supply a default implementation of Message Storage to the Mobile Messaging library during initialization. In this case the library will save all received Push messages using the <code>MMDefaultMessageStorage</code>. Library can also be initialized either without message storage or with user-provided one (see <code>withMessageStorage(messageStorage:)</code>).
- (MobileMessaging * _Nonnull)withDefaultMessageStorage SWIFT_WARN_UNUSED_RESULT;
/// Fabric method for Mobile Messaging session.
/// It is possible to supply an implementation of Message Storage to the Mobile Messaging library during initialization. In this case the library will save all received Push messages to the supplied <code>messageStorage</code>. Library can also be initialized either without message storage or with the default message storage (see <code>withDefaultMessageStorage()</code> method).
/// \param messageStorage a storage object, that implements the <code>MessageStorage</code> protocol
///
- (MobileMessaging * _Nonnull)withMessageStorage:(id <MMMessageStorage> _Nonnull)messageStorage SWIFT_WARN_UNUSED_RESULT;
/// Fabric method for Mobile Messaging session.
/// MobileMessaging SDK by default registers for remote notifications during <code>MobileMessaging.start()</code> procedure. It is possible to disable this default behavior. This might be needed in case your app should support other push notifications vendors in addition to (or instead of) Infobip’s one, or you want to have a more flexible approach of when and where the user will be prompt to allow receiving Push Notifications.
/// remark:
/// Don’t forget to register for Push Notifications explicitly by calling <code>MobileMessaging.registerForRemoteNotifications()</code>.
- (MobileMessaging * _Nonnull)withoutRegisteringForRemoteNotifications SWIFT_WARN_UNUSED_RESULT;
/// Fabric method for Mobile Messaging session.
/// Use this method to enable Full-featured In-App notifications (more about this feature - https://github.com/infobip/mobile-messaging-sdk-ios/wiki/In-app-notifications#full-featured-in-app-notifications)
/// remark:
/// Without enabling Full-featured In-app notifications <code>MMNotificationMessageReceived</code> event is triggered, but In-App not processed and not displayed within WebView.
- (MobileMessaging * _Nonnull)withFullFeaturedInApps SWIFT_WARN_UNUSED_RESULT;
/// Fabric method for Mobile Messaging session.
/// MobileMessaging SDK by default contains logic to unregister from Remote Notifications in certain cases: when depersonalization transitions to the pending state; when you explicitly stop MobileMessaging. It is possible to disable this default behavior. This might be needed in case your app should support other push notifications vendors in addition to (or instead of) Infobip’s one.
/// remark:
/// We don’t recommend having multiple push notifications vendors functioning within the same application because they might collide and interfere with each other.
- (MobileMessaging * _Nonnull)withoutUnregisteringForRemoteNotifications SWIFT_WARN_UNUSED_RESULT;
/// Fabric method for Mobile Messaging session.
/// It is possible to disable a Mobile Messaging default Notification Center Delegate implementation (UserNotificationCenterDelegate.swift:38). This might be needed in case your app should support other push notifications vendors in addition to (or instead of) Infobip’s one. Implementing UNUserNotificationCenterDelegate protocol is required to handle user-selected actions from notifications, and to process notifications that arrive when your app is running in the foreground. (More details here https://developer.apple.com/documentation/usernotifications/unusernotificationcenterdelegate)
/// remark:
/// We don’t recommend having multiple push notifications vendors functioning within the same application because they might collide and interfere with each other.
- (MobileMessaging * _Nonnull)withoutOverridingNotificationCenterDelegate SWIFT_WARN_UNUSED_RESULT;
/// Asynchronously starts a new Mobile Messaging session.
/// This method should be called form AppDelegate’s <code>application(_:didFinishLaunchingWithOptions:)</code> callback.
/// remark:
/// For now, Mobile Messaging SDK doesn’t support Badge. You should handle the badge counter by yourself.
- (void)start:(void (^ _Nullable)(void))completion;
/// Asynchronously cleans up all persisted data.
/// Use this method to completely drop any data persisted by the SDK (i.e. internal SDK data, optional user data, optional messages metadata).
/// \param clearKeychain defines whether the internalId in keychain will be cleaned. True by default.
///
+ (void)cleanUpAndStop:(BOOL)clearKeychain completion:(void (^ _Nonnull)(void))completion;
/// Asynchronously stops all the currently running Mobile Messaging services.
/// attention:
/// This function doesn’t disable push notifications, they are still being received by the OS.
/// \param cleanUpData defines whether the Mobile Messaging internal storage will be dropped. False by default.
///
+ (void)stop:(BOOL)cleanUpData completion:(void (^ _Nullable)(void))completion;
/// Call this method to initiate the registration process with Apple Push Notification service. User will be promt to allow receiving Push Notifications.
+ (void)registerForRemoteNotifications;
/// Logging utility is used for:
/// <ul>
///   <li>
///     setting up the logging options and logging levels.
///   </li>
///   <li>
///     obtaining a path to the logs file in case the Logging utility is set up to log in file (logging options contains <code>.file</code> option).
///   </li>
/// </ul>
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) id <MMLogging> _Nullable logger;)
+ (id <MMLogging> _Nullable)logger SWIFT_WARN_UNUSED_RESULT;
+ (void)setLogger:(id <MMLogging> _Nullable)value;
/// This method handles a new APNs device token and updates user’s registration on the server.
/// This method should be called form AppDelegate’s <code>application(_:didRegisterForRemoteNotificationsWithDeviceToken:)</code> callback.
/// \param token A token that identifies a particular device to APNs.
///
+ (void)didRegisterForRemoteNotificationsWithDeviceToken:(NSData * _Nonnull)token;
/// This method handles incoming remote notifications and triggers sending procedure for delivery reports. The method should be called from AppDelegate’s <code>application(_:didReceiveRemoteNotification:fetchCompletionHandler:)</code> callback.
/// \param userInfo A dictionary that contains information related to the remote notification, potentially including a badge number for the app icon, an alert sound, an alert message to display to the user, a notification identifier, and custom data.
///
/// \param completionHandler A block to execute when the download operation is complete. The block is originally passed to AppDelegate’s <code>application(_:didReceiveRemoteNotification:fetchCompletionHandler:)</code> callback as a <code>fetchCompletionHandler</code> parameter. Mobile Messaging will execute this block after sending notification’s delivery report.
///
+ (void)didReceiveRemoteNotification:(NSDictionary * _Nonnull)userInfo fetchCompletionHandler:(void (^ _Nonnull)(UIBackgroundFetchResult))completionHandler;
/// Returns the default message storage if used. For more information see <code>MMDefaultMessageStorage</code> class description.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) MMDefaultMessageStorage * _Nullable defaultMessageStorage;)
+ (MMDefaultMessageStorage * _Nullable)defaultMessageStorage SWIFT_WARN_UNUSED_RESULT;
/// Synchronously retrieves current installation data such as APNs device token, badge number, etc.
/// For more information and examples see: <a href="https://github.com/infobip/mobile-messaging-sdk-ios/wiki/Users-and-installations">Users and installations</a>
+ (MMInstallation * _Nullable)getInstallation SWIFT_WARN_UNUSED_RESULT;
/// Synchronously retrieves current user data such as unique push registration id for the registered user, emails, phones, custom data, external user id, etc.
/// For more information and examples see: <a href="https://github.com/infobip/mobile-messaging-sdk-ios/wiki/Users-and-installations">Users and installations</a>
+ (MMUser * _Nullable)getUser SWIFT_WARN_UNUSED_RESULT;
/// Asynchronously fetches the user data from the server.
/// For more information and examples see: <a href="https://github.com/infobip/mobile-messaging-sdk-ios/wiki/User-profile">User profile</a>
/// \param completion The block to execute after the server responded.
///
/// \param user Fetched user. Contains actual data if not error happened.
///
/// \param error Optional error.
///
+ (void)fetchUserWithCompletion:(void (^ _Nonnull)(MMUser * _Nullable, NSError * _Nullable))completion;
/// Asynchronously fetches the installation data from the server.
/// For more information and examples see: <a href="https://github.com/infobip/mobile-messaging-sdk-ios/wiki/Users-and-installations">Users and installations</a>
/// \param completion The block to execute after the server responded.
///
/// \param installation Fetched installation. Contains actual data if not error happened.
///
/// \param error Optional error.
///
+ (void)fetchInstallationWithCompletion:(void (^ _Nonnull)(MMInstallation * _Nullable, NSError * _Nullable))completion;
/// Asynchronously saves changed user data on the server.
/// For more information and examples see: <a href="https://github.com/infobip/mobile-messaging-sdk-ios/wiki/User-profile">User profile</a>
/// \param user User data to save on server.
///
/// \param completion The block to execute after the server responded.
///
/// \param error Optional error.
///
+ (void)saveUser:(MMUser * _Nonnull)user completion:(void (^ _Nonnull)(NSError * _Nullable))completion;
/// Asynchronously saves changed installation (registration data, custom installation attributes abd system data) on the server.
/// For more information and examples see: <a href="https://github.com/infobip/mobile-messaging-sdk-ios/wiki/Users-and-installations">Users and installations</a>
/// \param installation Installation data to save on server.
///
/// \param completion The block to execute after the server responded.
///
/// \param error Optional error.
///
+ (void)saveInstallation:(MMInstallation * _Nonnull)installation completion:(void (^ _Nonnull)(NSError * _Nullable))completion;
/// Synchronously persists user data to the disk. Pivacy settings are applied according to <code>MobileMessaging.privacySettings</code> settings.
/// For more information and examples see: <a href="https://github.com/infobip/mobile-messaging-sdk-ios/wiki/Users-and-installations">Users and installations</a>
/// \param user User data to persist.
///
+ (void)persistUser:(MMUser * _Nonnull)user;
/// Synchronously persists installation data to the disk. Pivacy settings are applied according to <code>MobileMessaging.privacySettings</code> settings.
/// For more information and examples see: <a href="https://github.com/infobip/mobile-messaging-sdk-ios/wiki/Users-and-installations">Users and installations</a>
+ (void)persistInstallation:(MMInstallation * _Nonnull)installation;
/// Asynchronously ereases currently persisted user data associated with push registration along with messages in SDK storage.
/// User’s data synced over MobileMessaging is by default associated with created push registration. Depersonalizing an installation means that a push registration and device specific data will remain, but user’s data (such as first name, custom data, …) will be wiped out.
/// If you depersonalize an installation from person, there is a way to personalize it again by providing new user data (either by UserDataService data setters or <code>InstallationDataService.personalize()</code> method) in order to target this user specifically.
/// remark:
/// There is another version of depersonalize method that doesn’t require a <code>completion</code> parameter which means the SDK will handle any unsuccessful depersonalize request by itself. See the method documentation for more details. Use this method in following cases:
/// <ul>
///   <li>
///     you want to handle possible failures of server depersonalize request, retry and maintain pending depersonalize state by yourself
///   </li>
///   <li>
///     you’re syncing user data to our server;
///   </li>
///   <li>
///     your application has logout functionality;
///   </li>
///   <li>
///     you don’t want new personalized installation to be targeted by other user’s data, e.g. first name;
///   </li>
///   <li>
///     you want depersonalized installation from user and still be able to receive broadcast notifications (otherwise, you need to disable push registration via Installation.isPushRegistrationEnabled).
///   </li>
/// </ul>
/// For more information and examples see: <a href="https://github.com/infobip/mobile-messaging-sdk-ios/wiki/Users-and-installations">Users and installations</a>
/// \param completion The block to execute after the server responded.
///
/// \param status Current depersonalization status.
///
/// \param error Optional error.
///
+ (void)depersonalizeWithCompletion:(void (^ _Nonnull)(enum MMSuccessPending, NSError * _Nullable))completion;
/// Asynchronously personalizes current installation with a person on the server.
/// Each user can have Phone numbers, Emails and External user ID. These fields are unique identifiers of a user profile on Infobip platform and provide capability to personalize any app installation with a user profile. The platform provides data grouping functions based on these parameters. For example, if two installations of a particular app will try to save the same Phone number, then both of them will be collected under a single user. Phone number, Email and External user ID are also widely used when targeting users with messages across different channels via Infobip platform.
/// remark:
/// This API doesn’t depersonalize current installation from any person that it may be currently personalized with. In order to depersonalize current possible person from current installation and personalize it with another person at once, use another API:
/// \code
/// MobileMessaging.personalize(forceDepersonalize: true, userIdentity: userAttributes: completion:)
///
/// \endcodeFor more information and examples see: <a href="https://github.com/infobip/mobile-messaging-sdk-ios/wiki/Users-and-installations">Users and installations</a>
/// \param userIdentity A combination of phones, emails and an external user id that will form a unique key for a person.
///
/// \param userAttributes Optional user data to be saved for the person.
///
/// \param completion The block to execute after the server responded.
///
/// \param error Optional error.
///
+ (void)personalizeWithUserIdentity:(MMUserIdentity * _Nonnull)identity userAttributes:(MMUserAttributes * _Nullable)userAttributes completion:(void (^ _Nonnull)(NSError * _Nullable))completion;
/// Asynchronously personalizes current installation with a person on the server.
/// Each user can have Phone numbers, Emails and External user ID. These fields are unique identifiers of a user profile on Infobip platform and provide capability to personalize any app installation with a user profile. The platform provides data grouping functions based on these parameters. For example, if two installations of a particular app will try to save the same Phone number, then both of them will be collected under a single user. Phone number, Email and External user ID are also widely used when targeting users with messages across different channels via Infobip platform.
/// For more information and examples see: <a href="https://github.com/infobip/mobile-messaging-sdk-ios/wiki/Users-and-installations">Users and installations</a>
/// \param forceDepersonalize Determines whether or not the depersonalization should be performed on our server in order to depersonalize the installation from previous user profile.
///
/// \param userIdentity A combination of phones, emails and an external user id that will form a unique key for a person.
///
/// \param userAttributes Optional user data to be saved for the person.
///
/// \param completion The block to execute after the server responded.
///
/// \param error Optional error.
///
+ (void)personalizeWithForceDepersonalize:(BOOL)forceDepersonalize userIdentity:(MMUserIdentity * _Nonnull)userIdentity userAttributes:(MMUserAttributes * _Nullable)userAttributes completion:(void (^ _Nonnull)(NSError * _Nullable))completion;
/// Asynchronously sets a current users arbitrary installation as primary.
/// For more information and examples see: <a href="https://github.com/infobip/mobile-messaging-sdk-ios/wiki/Users-and-installations">Users and installations</a>
/// \param pushRegId Push Registration Id of the installation to be updated.
///
/// \param primary New primary value.
///
/// \param completion The block to execute after the server responded.
///
/// \param installations A list of installations. Contains actual data if no error happened.
///
/// \param error Optional error.
///
+ (void)setInstallationWithPushRegistrationId:(NSString * _Nonnull)pushRegId asPrimary:(BOOL)primary completion:(void (^ _Nonnull)(NSArray<MMInstallation *> * _Nullable, NSError * _Nullable))completion;
/// Asynchronously depersonalizes current users arbitrary installation from the current user.
/// For more information and examples see: <a href="https://github.com/infobip/mobile-messaging-sdk-ios/wiki/Users-and-installations">Users and installations</a>
/// \param pushRegId Push Registration Id of the installation to be depersonalized.
///
/// \param completion The block to execute after the server responded.
///
/// \param installations A list of installations. Contains actual data if no error happened.
///
/// \param error Optional error.
///
+ (void)depersonalizeInstallationWithPushRegistrationId:(NSString * _Nonnull)pushRegId completion:(void (^ _Nonnull)(NSArray<MMInstallation *> * _Nullable, NSError * _Nullable))completion;
/// Asynchronously fetches all installations personalized with the current user.
/// For more information and examples see: <a href="https://github.com/infobip/mobile-messaging-sdk-ios/wiki/Users-and-installations">Users and installations</a>
/// \param completion The block to execute after the server responded.
///
/// \param installations A list of fetched installations. Contains actual data if no error happened.
///
/// \param error Optional error.
///
+ (void)fetchInstallationsWithCompletion:(void (^ _Nonnull)(NSArray<MMInstallation *> * _Nullable, NSError * _Nullable))completion;
/// Asynchronously sets seen status for messages and sends a corresponding request to the server. If something went wrong, the library will repeat the request until it reaches the server.
/// \param messageIds Array of identifiers of messages that need to be marked as seen.
///
/// \param completion The block to execute after the seen status “SeenNotSent” is persisted. Synchronization with the server will be performed eventually.
///
+ (void)setSeenWithMessageIds:(NSArray<NSString *> * _Nonnull)messageIds completion:(void (^ _Nonnull)(void))completion;
/// Asynchronously sends mobile originated messages to the server.
/// \param messages Array of objects of <code>MM_MOMessage</code> class that need to be sent.
///
/// \param completion The block to execute after the server responded, passes an array of <code>MM_MOMessage</code> messages
///
/// \param messages List of messages sent if no error happened
///
/// \param error Optional error
///
+ (void)sendMessages:(NSArray<MM_MOMessage *> * _Nonnull)messages completion:(void (^ _Nonnull)(NSArray<MM_MOMessage *> * _Nullable, NSError * _Nullable))completion;
/// An auxillary component provides the convinient access to the user agent data.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) MMUserAgent * _Nonnull userAgent;)
+ (MMUserAgent * _Nonnull)userAgent SWIFT_WARN_UNUSED_RESULT;
/// The <code>MessageHandlingDelegate</code> protocol defines methods for responding to actionable notifications and receiving new notifications. You assign your delegate object to the <code>messageHandlingDelegate</code> property of the <code>MobileMessaging</code> class. The MobileMessaging SDK calls methods of your delegate at appropriate times to deliver information.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) id <MMMessageHandlingDelegate> _Nullable messageHandlingDelegate;)
+ (id <MMMessageHandlingDelegate> _Nullable)messageHandlingDelegate SWIFT_WARN_UNUSED_RESULT;
+ (void)setMessageHandlingDelegate:(id <MMMessageHandlingDelegate> _Nullable)value;
/// The <code>URLSessionConfiguration</code> used for all url connections in the SDK
/// Default value is <code>URLSessionConfiguration.default</code>.
/// You can provide your own configuration to define a custom NSURLProtocol, policies etc.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) NSURLSessionConfiguration * _Nonnull urlSessionConfiguration;)
+ (NSURLSessionConfiguration * _Nonnull)urlSessionConfiguration SWIFT_WARN_UNUSED_RESULT;
+ (void)setUrlSessionConfiguration:(NSURLSessionConfiguration * _Nonnull)value;
/// The <code>MMPrivacySettings</code> class encapsulates privacy settings that affect the SDK behaviour and business logic.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) MMPrivacySettings * _Nonnull privacySettings;)
+ (MMPrivacySettings * _Nonnull)privacySettings SWIFT_WARN_UNUSED_RESULT;
/// The number currently set as the badge of the app icon in Springboard.
/// Set to 0 (zero) to hide the badge number. The default value of this property is 0.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class) NSInteger badgeNumber;)
+ (NSInteger)badgeNumber SWIFT_WARN_UNUSED_RESULT;
+ (void)setBadgeNumber:(NSInteger)newValue;
/// Asynchronously submits a custom event and immediately sends it to the server. If any connection error occured or the server responded with “Bad request” error, you have to handle the error yourself, perform retries if needed.
/// \param customEvent Custom event to be sent to the server.
///
/// \param completion The block to execute after the server responded.
///
/// \param error Optional error.
///
+ (void)submitEvent:(MMCustomEvent * _Nonnull)customEvent completion:(void (^ _Nonnull)(NSError * _Nullable))completion;
/// Asynchronously submits the custom event and sends it to the server eventually. If something went wrong during the communication with the server, the request will be retied until the event succesfully accepted.
/// \param customEvent Custom event to be sent to the server.
///
+ (void)submitEvent:(MMCustomEvent * _Nonnull)customEvent;
/// You can define your own custom appearance for in-app webView, which will appear if user taps on push notification, by accessing a webView settings object.
@property (nonatomic, readonly, strong) MMWebViewSettings * _Nonnull webViewSettings;
/// Displays <code>MODAL</code> in-app notification for provided message, if message isn’t expired.
/// \param message <code>MM_MTMessage</code> object.
///
+ (void)showModalInAppNotificationForMessage:(MM_MTMessage * _Nonnull)message;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, strong) MobileMessaging * _Nullable sharedInstance;)
+ (MobileMessaging * _Nullable)sharedInstance SWIFT_WARN_UNUSED_RESULT;
+ (void)setSharedInstance:(MobileMessaging * _Nullable)value;
@property (nonatomic, readonly, strong) MMUserNotificationType * _Nonnull userNotificationType;
@property (nonatomic, readonly, copy) NSString * _Nonnull applicationCode;
@property (nonatomic, readonly, copy) NSString * _Nonnull remoteAPIBaseURL;
- (InternalData * _Nonnull)internalData SWIFT_WARN_UNUSED_RESULT;
- (MMInstallation * _Nonnull)currentInstallation SWIFT_WARN_UNUSED_RESULT;
- (MMInstallation * _Nonnull)resolveInstallation SWIFT_WARN_UNUSED_RESULT;
@property (nonatomic, strong) MMMessageHandler * _Null_unspecified messageHandler;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) NSTimeZone * _Nonnull timeZone;)
+ (NSTimeZone * _Nonnull)timeZone SWIFT_WARN_UNUSED_RESULT;
+ (void)setTimeZone:(NSTimeZone * _Nonnull)value;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, copy) NSCalendar * _Nonnull calendar;)
+ (NSCalendar * _Nonnull)calendar SWIFT_WARN_UNUSED_RESULT;
+ (void)setCalendar:(NSCalendar * _Nonnull)value;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


@interface MobileMessaging (SWIFT_EXTENSION(MobileMessaging))
/// Fabric method for Mobile Messaging session.
/// App Groups used to share data among app Notification Extension and the main application itself. Provide the appropriate App Group ID for both application and application extension in order to keep them in sync.
/// remark:
/// If you are facing with the following error in your console:
/// <code>[User Defaults] Failed to read values in CFPrefsPlistSource<0xXXXXXXX> (Domain: ..., User: kCFPreferencesAnyUser, ByHost: Yes, Container: (null)): Using kCFPreferencesAnyUser with a container is only allowed for SystemContainers, detaching from cfprefsd</code>.
/// Although this warning doesn’t mean that our code doesn’t work, you can shut it up by prefixing your App Group ID with a Team ID of a certificate that you are signing the build with. For example: <code>"9S95Y6XXXX.group.com.mobile-messaging.notification-service-extension"</code>. The App Group ID itself doesn’t need to be changed though.
/// \param appGroupId An ID of an App Group
///
- (MobileMessaging * _Nonnull)withAppGroupId:(NSString * _Nonnull)appGroupId SWIFT_WARN_UNUSED_RESULT SWIFT_DEPRECATED_MSG("The function is deprecated. Please put your App Group Id as a String value for a key `com.mobilemessaging.app_group` in your main info dictionary (Info.plist by default).");
@end


@interface MobileMessaging (SWIFT_EXTENSION(MobileMessaging))
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) MMInboxService * _Nullable inbox;)
+ (MMInboxService * _Nullable)inbox SWIFT_WARN_UNUSED_RESULT;
@end


@interface MobileMessaging (SWIFT_EXTENSION(MobileMessaging))
/// This service manages geofencing areas, emits geografical regions entering/exiting notifications.
/// You access the Geofencing service APIs through this property.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) MMGeofencingService * _Nullable geofencingService;)
+ (MMGeofencingService * _Nullable)geofencingService SWIFT_WARN_UNUSED_RESULT;
/// Fabric method for Mobile Messaging session.
/// Use this method to enable the Geofencing service.
- (MobileMessaging * _Nonnull)withGeofencingService SWIFT_WARN_UNUSED_RESULT;
@end


@interface MobileMessaging (SWIFT_EXTENSION(MobileMessaging))
/// You access the In-app Chat service APIs through this property.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) MMInAppChatService * _Nullable inAppChat;)
+ (MMInAppChatService * _Nullable)inAppChat SWIFT_WARN_UNUSED_RESULT;
/// Fabric method for Mobile Messaging session.
/// Use this method to enable the In-app Chat service.
- (MobileMessaging * _Nonnull)withInAppChat SWIFT_WARN_UNUSED_RESULT;
@end


@interface MobileMessaging (SWIFT_EXTENSION(MobileMessaging))
/// Fabric method for Mobile Messaging session.
/// remark:
/// Mobile Messaging SDK reserves category Ids and action Ids with “mm_” prefix. Custom actions and categories with this prefix will be discarded.
/// \param categories Set of categories to define which buttons to display and their behavour.
///
- (MobileMessaging * _Nonnull)withInteractiveNotificationCategories:(NSSet<MMNotificationCategory *> * _Nonnull)categories SWIFT_WARN_UNUSED_RESULT;
/// This method handles interactive notifications actions and performs work that is defined for this action.
/// \param identifier The identifier for the interactive notification action.
///
/// \param message The <code>MM_MTMessage</code> object the action associated with.
///
/// \param responseInfo The data dictionary sent by the action. Potentially could contain text entered by the user in response to the text input action.
///
/// \param completionHandler A block that you must call when you are finished performing the action.
///
+ (void)handleActionWithIdentifier:(NSString * _Nullable)identifier category:(NSString * _Nullable)category message:(MM_MTMessage * _Nullable)message notificationUserInfo:(NSDictionary<NSString *, id> * _Nullable)notificationUserInfo userText:(NSString * _Nullable)userText completionHandler:(void (^ _Nonnull)(void))completionHandler;
/// Returns <code>MMNotificationCategory</code> object for provided category Id. Category Id can be obtained from <code>MM_MTMessage</code> object with <code>MTMessage.category</code> method.
/// \param identifier The identifier associated with the category of interactive notification
///
+ (MMNotificationCategory * _Nullable)categoryWithId:(NSString * _Nonnull)identifier SWIFT_WARN_UNUSED_RESULT;
@end


@interface MobileMessaging (SWIFT_EXTENSION(MobileMessaging))
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) MMInstallation * _Nullable currentInstallation;)
+ (MMInstallation * _Nullable)currentInstallation SWIFT_WARN_UNUSED_RESULT;
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) MMUser * _Nullable currentUser;)
+ (MMUser * _Nullable)currentUser SWIFT_WARN_UNUSED_RESULT;
@end

@class UNNotificationRequest;
@class UNNotificationContent;

SWIFT_CLASS("_TtC15MobileMessaging43MobileMessagingNotificationServiceExtension")
@interface MobileMessagingNotificationServiceExtension : NSObject
/// Starts a new Mobile Messaging Notification Service Extension session.
/// This method should be called form <code>didReceive(_:, withContentHandler:)</code> of your subclass of UNNotificationServiceExtension.
/// remark:
/// If you are facing with the following error in your console:
/// <code>[User Defaults] Failed to read values in CFPrefsPlistSource<0xXXXXXXX> (Domain: ..., User: kCFPreferencesAnyUser, ByHost: Yes, Container: (null)): Using kCFPreferencesAnyUser with a container is only allowed for SystemContainers, detaching from cfprefsd</code>.
/// Although this warning doesn’t mean that our code doesn’t work, you can shut it up by prefixing your App Group ID with a Team ID of a certificate that you are signing the build with. For example: <code>"9S95Y6XXXX.group.com.mobile-messaging.notification-service-extension"</code>. The App Group ID itself doesn’t need to be changed though.
/// \param code The application code of your Application from Push Portal website.
///
/// \param appGroupId An ID of an App Group. App Groups used to share data among app Notification Extension and the main application itself. Provide the appropriate App Group ID for both application and application extension in order to keep them in sync.
///
+ (void)startWithApplicationCode:(NSString * _Nonnull)code appGroupId:(NSString * _Nonnull)appGroupId SWIFT_DEPRECATED_MSG("The function is deprecated. Plese use `startWithApplicationCode(_ applicationCode: String)` instead and put your App Group Id as a String value for a key `com.mobilemessaging.app_group` respectively in your main info dictionary (info .plist file).");
/// Starts a new Mobile Messaging Notification Service Extension session.
/// This method should be called form <code>didReceive(_:, withContentHandler:)</code> of your subclass of UNNotificationServiceExtension.
/// <em>It is required for the session start to put your App Group Id as a String value for a key</em> <code>com.mobilemessaging.app_group</code> <em>in your main info dictionary (info .plist file)</em>
/// remark:
/// If you are facing with the following error in your console:
/// <code>[User Defaults] Failed to read values in CFPrefsPlistSource<0xXXXXXXX> (Domain: ..., User: kCFPreferencesAnyUser, ByHost: Yes, Container: (null)): Using kCFPreferencesAnyUser with a container is only allowed for SystemContainers, detaching from cfprefsd</code>.
/// Although this warning doesn’t mean that our code doesn’t work, you can shut it up by prefixing your App Group ID with a Team ID of a certificate that you are signing the build with. For example: <code>"9S95Y6XXXX.group.com.mobile-messaging.notification-service-extension"</code>. The App Group ID itself doesn’t need to be changed though.
/// \param applicationCode The application code of your Application from Push Portal website.
///
+ (void)startWithApplicationCode:(NSString * _Nonnull)applicationCode;
/// This method handles an incoming notification on the Notification Service Extensions side. It performs message delivery reporting and downloads data from <code>contentUrl</code> if provided. This method must be called within <code>UNNotificationServiceExtension.didReceive(_: withContentHandler:)</code> callback.
/// \param request The original notification request. Use this object to get the original content of the notification.
///
/// \param contentHandler The block to execute with the modified content. The block will be called after the delivery reporting and contend downloading finished.
///
+ (void)didReceive:(UNNotificationRequest * _Nonnull)request withContentHandler:(void (^ _Nonnull)(UNNotificationContent * _Nonnull))contentHandler;
/// This method handles an incoming notification on the Notification Service Extensions side. It performs message delivery reporting and downloads data from <code>contentUrl</code> if provided. This method must be called within <code>UNNotificationServiceExtension.didReceive(_: withContentHandler:)</code> callback.
/// \param content The notification request content.
///
/// \param contentHandler The block to execute with the modified content. The block will be called after the delivery reporting and contend downloading finished.
///
+ (void)didReceiveWithContent:(UNNotificationContent * _Nonnull)content withContentHandler:(void (^ _Nonnull)(UNNotificationContent * _Nonnull))contentHandler;
+ (void)serviceExtensionTimeWillExpire;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



@interface NSArray<ObjectType> (SWIFT_EXTENSION(MobileMessaging)) <MMAttributeType>
@end


@interface NSDate (SWIFT_EXTENSION(MobileMessaging)) <MMAttributeType>
@end




@interface NSError (SWIFT_EXTENSION(MobileMessaging))
@property (nonatomic, readonly, copy) NSString * _Nullable mm_message;
@property (nonatomic, readonly, copy) NSString * _Nullable mm_code;
@end








@interface NSNull (SWIFT_EXTENSION(MobileMessaging)) <MMAttributeType>
@end


@interface NSNumber (SWIFT_EXTENSION(MobileMessaging)) <MMAttributeType>
@end




@interface NSString (SWIFT_EXTENSION(MobileMessaging)) <MMAttributeType>
@end



SWIFT_CLASS("_TtC15MobileMessaging31NotificationsInteractionService")
@interface NotificationsInteractionService : MobileMessagingService
@end







/// Responsible for handling all delegate callbacks for the underlying session.
SWIFT_CLASS("_TtC15MobileMessaging15SessionDelegate")
@interface SessionDelegate : NSObject
/// Initializes the <code>SessionDelegate</code> instance.
///
/// returns:
/// The new <code>SessionDelegate</code> instance.
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/// Returns a <code>Bool</code> indicating whether the <code>SessionDelegate</code> implements or inherits a method that can respond
/// to a specified message.
/// \param selector A selector that identifies a message.
///
///
/// returns:
/// <code>true</code> if the receiver implements or inherits a method that can respond to selector, otherwise <code>false</code>.
- (BOOL)respondsToSelector:(SEL _Nonnull)selector SWIFT_WARN_UNUSED_RESULT;
@end

@class NSURLSession;
@class NSURLSessionDownloadTask;

@interface SessionDelegate (SWIFT_EXTENSION(MobileMessaging)) <NSURLSessionDownloadDelegate>
/// Tells the delegate that a download task has finished downloading.
/// \param session The session containing the download task that finished.
///
/// \param downloadTask The download task that finished.
///
/// \param location A file URL for the temporary file. Because the file is temporary, you must either
/// open the file for reading or move it to a permanent location in your app’s sandbox
/// container directory before returning from this delegate method.
///
- (void)URLSession:(NSURLSession * _Nonnull)session downloadTask:(NSURLSessionDownloadTask * _Nonnull)downloadTask didFinishDownloadingToURL:(NSURL * _Nonnull)location;
/// Periodically informs the delegate about the download’s progress.
/// \param session The session containing the download task.
///
/// \param downloadTask The download task.
///
/// \param bytesWritten The number of bytes transferred since the last time this delegate
/// method was called.
///
/// \param totalBytesWritten The total number of bytes transferred so far.
///
/// \param totalBytesExpectedToWrite The expected length of the file, as provided by the Content-Length
/// header. If this header was not provided, the value is
/// <code>NSURLSessionTransferSizeUnknown</code>.
///
- (void)URLSession:(NSURLSession * _Nonnull)session downloadTask:(NSURLSessionDownloadTask * _Nonnull)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite;
/// Tells the delegate that the download task has resumed downloading.
/// \param session The session containing the download task that finished.
///
/// \param downloadTask The download task that resumed. See explanation in the discussion.
///
/// \param fileOffset If the file’s cache policy or last modified date prevents reuse of the
/// existing content, then this value is zero. Otherwise, this value is an
/// integer representing the number of bytes on disk that do not need to be
/// retrieved again.
///
/// \param expectedTotalBytes The expected length of the file, as provided by the Content-Length header.
/// If this header was not provided, the value is NSURLSessionTransferSizeUnknown.
///
- (void)URLSession:(NSURLSession * _Nonnull)session downloadTask:(NSURLSessionDownloadTask * _Nonnull)downloadTask didResumeAtOffset:(int64_t)fileOffset expectedTotalBytes:(int64_t)expectedTotalBytes;
@end

@class NSURLSessionDataTask;
@class NSURLResponse;
@class NSCachedURLResponse;

@interface SessionDelegate (SWIFT_EXTENSION(MobileMessaging)) <NSURLSessionDataDelegate>
/// Tells the delegate that the data task received the initial reply (headers) from the server.
/// \param session The session containing the data task that received an initial reply.
///
/// \param dataTask The data task that received an initial reply.
///
/// \param response A URL response object populated with headers.
///
/// \param completionHandler A completion handler that your code calls to continue the transfer, passing a
/// constant to indicate whether the transfer should continue as a data task or
/// should become a download task.
///
- (void)URLSession:(NSURLSession * _Nonnull)session dataTask:(NSURLSessionDataTask * _Nonnull)dataTask didReceiveResponse:(NSURLResponse * _Nonnull)response completionHandler:(void (^ _Nonnull)(NSURLSessionResponseDisposition))completionHandler;
/// Tells the delegate that the data task was changed to a download task.
/// \param session The session containing the task that was replaced by a download task.
///
/// \param dataTask The data task that was replaced by a download task.
///
/// \param downloadTask The new download task that replaced the data task.
///
- (void)URLSession:(NSURLSession * _Nonnull)session dataTask:(NSURLSessionDataTask * _Nonnull)dataTask didBecomeDownloadTask:(NSURLSessionDownloadTask * _Nonnull)downloadTask;
/// Tells the delegate that the data task has received some of the expected data.
/// \param session The session containing the data task that provided data.
///
/// \param dataTask The data task that provided data.
///
/// \param data A data object containing the transferred data.
///
- (void)URLSession:(NSURLSession * _Nonnull)session dataTask:(NSURLSessionDataTask * _Nonnull)dataTask didReceiveData:(NSData * _Nonnull)data;
/// Asks the delegate whether the data (or upload) task should store the response in the cache.
/// \param session The session containing the data (or upload) task.
///
/// \param dataTask The data (or upload) task.
///
/// \param proposedResponse The default caching behavior. This behavior is determined based on the current
/// caching policy and the values of certain received headers, such as the Pragma
/// and Cache-Control headers.
///
/// \param completionHandler A block that your handler must call, providing either the original proposed
/// response, a modified version of that response, or NULL to prevent caching the
/// response. If your delegate implements this method, it must call this completion
/// handler; otherwise, your app leaks memory.
///
- (void)URLSession:(NSURLSession * _Nonnull)session dataTask:(NSURLSessionDataTask * _Nonnull)dataTask willCacheResponse:(NSCachedURLResponse * _Nonnull)proposedResponse completionHandler:(void (^ _Nonnull)(NSCachedURLResponse * _Nullable))completionHandler;
@end

@class NSURLSessionStreamTask;
@class NSInputStream;
@class NSOutputStream;

SWIFT_AVAILABILITY(tvos,introduced=9.0) SWIFT_AVAILABILITY(macos,introduced=10.11) SWIFT_AVAILABILITY(ios,introduced=9.0)
@interface SessionDelegate (SWIFT_EXTENSION(MobileMessaging)) <NSURLSessionStreamDelegate>
/// Tells the delegate that the read side of the connection has been closed.
/// \param session The session.
///
/// \param streamTask The stream task.
///
- (void)URLSession:(NSURLSession * _Nonnull)session readClosedForStreamTask:(NSURLSessionStreamTask * _Nonnull)streamTask;
/// Tells the delegate that the write side of the connection has been closed.
/// \param session The session.
///
/// \param streamTask The stream task.
///
- (void)URLSession:(NSURLSession * _Nonnull)session writeClosedForStreamTask:(NSURLSessionStreamTask * _Nonnull)streamTask;
/// Tells the delegate that the system has determined that a better route to the host is available.
/// \param session The session.
///
/// \param streamTask The stream task.
///
- (void)URLSession:(NSURLSession * _Nonnull)session betterRouteDiscoveredForStreamTask:(NSURLSessionStreamTask * _Nonnull)streamTask;
/// Tells the delegate that the stream task has been completed and provides the unopened stream objects.
/// \param session The session.
///
/// \param streamTask The stream task.
///
/// \param inputStream The new input stream.
///
/// \param outputStream The new output stream.
///
- (void)URLSession:(NSURLSession * _Nonnull)session streamTask:(NSURLSessionStreamTask * _Nonnull)streamTask didBecomeInputStream:(NSInputStream * _Nonnull)inputStream outputStream:(NSOutputStream * _Nonnull)outputStream;
@end

@class NSURLAuthenticationChallenge;
@class NSURLCredential;

@interface SessionDelegate (SWIFT_EXTENSION(MobileMessaging)) <NSURLSessionDelegate>
/// Tells the delegate that the session has been invalidated.
/// \param session The session object that was invalidated.
///
/// \param error The error that caused invalidation, or nil if the invalidation was explicit.
///
- (void)URLSession:(NSURLSession * _Nonnull)session didBecomeInvalidWithError:(NSError * _Nullable)error;
/// Requests credentials from the delegate in response to a session-level authentication request from the
/// remote server.
/// \param session The session containing the task that requested authentication.
///
/// \param challenge An object that contains the request for authentication.
///
/// \param completionHandler A handler that your delegate method must call providing the disposition
/// and credential.
///
- (void)URLSession:(NSURLSession * _Nonnull)session didReceiveChallenge:(NSURLAuthenticationChallenge * _Nonnull)challenge completionHandler:(void (^ _Nonnull)(NSURLSessionAuthChallengeDisposition, NSURLCredential * _Nullable))completionHandler;
/// Tells the delegate that all messages enqueued for a session have been delivered.
/// \param session The session that no longer has any outstanding requests.
///
- (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession * _Nonnull)session;
@end

@class NSURLSessionTask;
@class NSHTTPURLResponse;
@class NSURLRequest;
@class NSURLSessionTaskMetrics;

@interface SessionDelegate (SWIFT_EXTENSION(MobileMessaging)) <NSURLSessionTaskDelegate>
/// Tells the delegate that the remote server requested an HTTP redirect.
/// \param session The session containing the task whose request resulted in a redirect.
///
/// \param task The task whose request resulted in a redirect.
///
/// \param response An object containing the server’s response to the original request.
///
/// \param request A URL request object filled out with the new location.
///
/// \param completionHandler A closure that your handler should call with either the value of the request
/// parameter, a modified URL request object, or NULL to refuse the redirect and
/// return the body of the redirect response.
///
- (void)URLSession:(NSURLSession * _Nonnull)session task:(NSURLSessionTask * _Nonnull)task willPerformHTTPRedirection:(NSHTTPURLResponse * _Nonnull)response newRequest:(NSURLRequest * _Nonnull)request completionHandler:(void (^ _Nonnull)(NSURLRequest * _Nullable))completionHandler;
/// Requests credentials from the delegate in response to an authentication request from the remote server.
/// \param session The session containing the task whose request requires authentication.
///
/// \param task The task whose request requires authentication.
///
/// \param challenge An object that contains the request for authentication.
///
/// \param completionHandler A handler that your delegate method must call providing the disposition
/// and credential.
///
- (void)URLSession:(NSURLSession * _Nonnull)session task:(NSURLSessionTask * _Nonnull)task didReceiveChallenge:(NSURLAuthenticationChallenge * _Nonnull)challenge completionHandler:(void (^ _Nonnull)(NSURLSessionAuthChallengeDisposition, NSURLCredential * _Nullable))completionHandler;
/// Tells the delegate when a task requires a new request body stream to send to the remote server.
/// \param session The session containing the task that needs a new body stream.
///
/// \param task The task that needs a new body stream.
///
/// \param completionHandler A completion handler that your delegate method should call with the new body stream.
///
- (void)URLSession:(NSURLSession * _Nonnull)session task:(NSURLSessionTask * _Nonnull)task needNewBodyStream:(void (^ _Nonnull)(NSInputStream * _Nullable))completionHandler;
/// Periodically informs the delegate of the progress of sending body content to the server.
/// \param session The session containing the data task.
///
/// \param task The data task.
///
/// \param bytesSent The number of bytes sent since the last time this delegate method was called.
///
/// \param totalBytesSent The total number of bytes sent so far.
///
/// \param totalBytesExpectedToSend The expected length of the body data.
///
- (void)URLSession:(NSURLSession * _Nonnull)session task:(NSURLSessionTask * _Nonnull)task didSendBodyData:(int64_t)bytesSent totalBytesSent:(int64_t)totalBytesSent totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend;
/// Tells the delegate that the session finished collecting metrics for the task.
/// \param session The session collecting the metrics.
///
/// \param task The task whose metrics have been collected.
///
/// \param metrics The collected metrics.
///
- (void)URLSession:(NSURLSession * _Nonnull)session task:(NSURLSessionTask * _Nonnull)task didFinishCollectingMetrics:(NSURLSessionTaskMetrics * _Nonnull)metrics SWIFT_AVAILABILITY(tvos,introduced=10.0) SWIFT_AVAILABILITY(macos,introduced=10.12) SWIFT_AVAILABILITY(ios,introduced=10.0);
/// Tells the delegate that the task finished transferring data.
/// \param session The session containing the task whose request finished transferring data.
///
/// \param task The task whose request finished transferring data.
///
/// \param error If an error occurred, an error object indicating how the transfer failed, otherwise nil.
///
- (void)URLSession:(NSURLSession * _Nonnull)session task:(NSURLSessionTask * _Nonnull)task didCompleteWithError:(NSError * _Nullable)error;
@end


@interface UIActivityIndicatorView (SWIFT_EXTENSION(MobileMessaging)) <MMActivityIndicatorProtocol>
@end
































#endif
#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#if defined(__cplusplus)
#endif
#pragma clang diagnostic pop
#endif

#else
#error unsupported Swift architecture
#endif
